#! /Applications/Nuke14.0v5/Nuke14.0v5.app/Contents/MacOS/libnuke-14.0.5.dylib -nx
version 14.0 v5
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="-1921" y="25" w="1920" h="1147" maximized="1" screen="1">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1257" stretch="1"/>
            <splitter orientation="2">
                <split size="671"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                </dock>
                <split size="472"/>
                <dock id="" activePageId="DAG.1" focus="true">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                </dock>
            </splitter>
            <split size="615"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
                <page id="Scenegraph.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /Users/nick/Dropbox/MacPro_Jobs/AMPAS/output_transforms/Nuke/CAMDRT_breakout_v002.nk
 frame 58
 last_frame 78
 lock_range true
 colorManagement Nuke
 OCIO_config custom
 customOCIOConfigPath /Users/afry/Documents/GitHub/OpenColorIO-Configs/aces_1.2/config.ocio
 workingSpaceLUT linear
 monitorLut sRGB
 monitorOutLUT rec709
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
BackdropNode {
 inputs 0
 name BackdropNode1
 tile_color 0x7171c600
 label complete
 note_font_size 42
 xpos -917
 ypos 720
 bdheight 168
}
BackdropNode {
 inputs 0
 name BackdropNode2
 tile_color 0x7171c600
 label "output input as luminanceXYZ"
 note_font_size 42
 xpos -498
 ypos 524
 bdheight 168
}
BackdropNode {
 inputs 0
 name BackdropNode3
 tile_color 0x388e8e00
 label "convert luminanceXYZ to JMh"
 note_font_size 42
 xpos -498
 ypos 726
 bdheight 168
}
BackdropNode {
 inputs 0
 name BackdropNode4
 tile_color 0x99993cff
 gl_color 0xffffa0ff
 label "JMh to tonemappedJMh"
 note_font_size 42
 xpos -498
 ypos 897
 bdheight 168
}
BackdropNode {
 inputs 0
 name BackdropNode5
 tile_color 0x388e8e00
 label "JMh to gamut compressed JMh"
 note_font_size 42
 xpos -498
 ypos 1096
 bdheight 168
}
BackdropNode {
 inputs 0
 name BackdropNode6
 tile_color 0x8e388e00
 label "JMh to luminance XYZ"
 note_font_size 42
 xpos -498
 ypos 1302
 bdheight 168
}
BackdropNode {
 inputs 0
 name BackdropNode7
 tile_color 0x388e8e00
 label "luminance XYZ to luminanceRGB"
 note_font_size 42
 xpos -498
 ypos 1512
 bdheight 168
}
BackdropNode {
 inputs 0
 name BackdropNode8
 tile_color 0x388e8e00
 label "luminanceRGB to output RGB"
 note_font_size 42
 xpos -498
 ypos 1743
 bdheight 168
}
BackdropNode {
 inputs 0
 name BackdropNode9
 tile_color 0x99993bff
 label "Separated tonemap\nand chroma compression"
 note_font_size 36
 xpos 189
 ypos 700
 bdwidth 403
 bdheight 354
}
Isabella {
 inputs 0
 name Isabella1
 label "\[value Colourspace]"
 xpos -1208
 ypos 317
 Colourspace ACES2065-1
}
Read {
 inputs 0
 file_type exr
 file /Volumes/SSD_4TB_01/images1/ACES_OT_VWG_SampleFrames/ACES_OT_VWG_SampleFrames.####.exr
 format "1920 1080 0 0 1920 1080 1 HD_1080"
 last 78
 origlast 78
 origset true
 name Read1
 xpos -498
 ypos 92
}
Read {
 inputs 0
 file_type exr
 file /Users/nick/Downloads/Spectral_Cornell_Boxes_Standard_Human_Observer.exr
 format "4608 2560 0 0 4608 2560 1 "
 origset true
 name Read7
 xpos -907
 ypos 182
}
Dot {
 name Dot24
 xpos -873
 ypos 581
}
set N12ad4600 [stack 0]
Group {
 name DRT_CAM45
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos -907
 ypos 800
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {6 BlinkScript1_DRT_CAM_Kernel_simpleCompressMode l simpleCompressMode -STARTLINE}
 BlinkScript1_DRT_CAM_Kernel_simpleCompressMode true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit P3-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 1000
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.7 1.2 1.7 1}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_AP1compressmode l AP1compressmode T BlinkScript1.DRT_CAM_Kernel_AP1compressmode}
 addUserKnob {6 BlinkScript1_DRT_CAM_Kernel_Locuscompressmode l Locuscompressmode +STARTLINE}
 BlinkScript1_DRT_CAM_Kernel_Locuscompressmode true
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.2 1.4 {compressionFuncParamsR.g} 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {{compressionFuncParamsR.r} 1.21 {compressionFuncParamsY.g} 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {{compressionFuncParamsR.r} 1.3 {compressionFuncParamsG.g} 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {{compressionFuncParamsR.r} 1.9 {compressionFuncParamsC.g} 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {{compressionFuncParamsR.r} 1.2 {compressionFuncParamsB.g} 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {{compressionFuncParamsR.r} 1.23 {compressionFuncParamsM.g} 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out sRGB
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out P3-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name extra
  xpos -1244
  ypos -259
  number 1
 }
 Reformat {
  inputs 0
  name Reformat1
  xpos -1120
  ypos -264
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input1]"}}
  name Switch1
  xpos -1120
  ypos -195
 }
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  inputs 2
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v038.blink
  recompileCount 2561
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b01ab31261204a9edd5ee1cd13bdd2e603d7a9a00100add44c8b8f3d5ce677ab 3 \"src\" Read Point \"extra\" Read Point \"dst\" Write Point 74 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"simpleCompressMode\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"AP1compressmode\" Bool 1 AA== \"Locuscompressmode\" Bool 1 AA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 74 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"simpleCompressMode\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"AP1compressmode\" 1 1 \"Locuscompressmode\" 1 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 52 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTableUnsortedAP1\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTableAP1\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LocusLimitMTable\" Float 1 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> extra; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n    bool simpleCompressMode;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n    bool AP1compressmode;\n    bool Locuscompressmode;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    float3x3 AP1_to_XYZ;\n    float3x3 XYZ_to_AP1;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 gamutCuspTableUnsortedAP1\[360];\n    float3 gamutCuspTableAP1\[360];\n    float3 cgamutCuspTable\[360];\n    float LocusLimitMTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n\n    // switch to treat incoming data as luminanceXYZ when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      luminanceXYZ = JMh;\n    \}\n\n\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    // return luminanceRGB when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      return luminanceRGB;\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n  // convert linear RGB values with the AP1 primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 AP1_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(AP1_to_XYZ, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n    float2 cuspFromTableAP1(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTableAP1\[0].z )\n    \{\n      lo = gamutCuspTableAP1\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTableAP1\[0];\n    \}\n    else if( h >= gamutCuspTableAP1\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTableAP1\[gamutCuspTableSize-1];\n      hi = gamutCuspTableAP1\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTableAP1\[i].z )\n        \{\n          lo = gamutCuspTableAP1\[i-1];\n          hi = gamutCuspTableAP1\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n\n  float2 cuspFromTableLocus(float h)\n  \{\n\n    // float lo;\n    // float hi;\n\n    // if( h <= LocusLimitMTable\[0] )\n    // \{\n    //   lo = LocusLimitMTable\[gamutCuspTableSize-1];\n    //   lo = lo-360.0f;\n    //   hi = LocusLimitMTable\[0];\n    // \}\n    // else if( h >= LocusLimitMTable\[gamutCuspTableSize-1] )\n    // \{\n    //   lo = LocusLimitMTable\[gamutCuspTableSize-1];\n    //   hi = LocusLimitMTable\[0];\n    //   hi = hi+360.f;\n    // \}\n    // else\n    // \{\n    //   for(int i = 1; i < gamutCuspTableSize; ++i)\n    //   \{\n    //     if( h <= LocusLimitMTable\[i] )\n    //     \{\n    //       lo = LocusLimitMTable\[i-1];\n    //       hi = LocusLimitMTable\[i];\n    //       break;\n    //     \}\n    //   \}\n    // \}\n\n    // float t = (h - lo) / (hi - lo);\n\n    float cuspJ = 69;\n    // float cuspM = lerp(lo, hi, t);\n    float cuspM = LocusLimitMTable\[int(h)];\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (simpleCompressMode)\n    \{\n      if (!invert)\n      \{\n        M =  JMh.y * ( JMh.x / origJ);\n      \}\n      else\n      \{\n        M =  JMh.y * ( JMh.x / origJ);\n      \}\n      return M;\n    \}\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n      M = min(M,JMh.y);\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6 || diagnosticMode == 100)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n  float3 getLocusBoundry(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float2 cuspLocus = cuspFromTableLocus(h);\n    float cuspTarget100 = cuspLocus.y;\n    // 0.86 has been eyeballed to match the locus in Nuke\n    float cuspTarget = cuspTarget100 * pow((Jmh.x/100.0f),0.86f);\n    float difference =  cuspLocus.y / cuspTarget;\n    return float3(Jmh.x,cuspTarget,Jmh.z);\n  \}\n\n\n  float4 getCompressionFuncParams(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float angleR = 20.0f;\n    float angleY = 102.0f;\n    float angleG = 146.0f;\n    float angleC = 193.0f;\n    float angleB = 259.0f;\n    float angleM = 342.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if(AP1compressmode)\n    \{\n        float2 cuspAP1 = cuspFromTableAP1(h);\n        float2 cuspTarget = cuspFromTable(h);\n        float difference =  cuspAP1.y / cuspTarget.y;\n        return float4(0.2,difference,difference,1.0);\n    \}\n    if(Locuscompressmode)\n    \{\n        // float2 cuspLocus = cuspFromTableLocus(h);\n        float cuspTarget = cuspFromTable(h).y;\n        float locusMax = getLocusBoundry(Jmh).y;\n        // float cuspTarget = cuspTarget100 * (Jmh.x/100.0f);\n        float difference =  locusMax / Jmh.y;\n        // float difference = Jmh.y;\n        return float4(compressionFuncParams.x,difference,difference,compressionFuncParams.w);\n        // return float4(compressionFuncParams.x,locusMax,Jmh.y,compressionFuncParams.w);\n    \}\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    // float2 project_to = float2(project_from.x, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n    // float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_from, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMh.x,JMboundary.y,JMh.z));\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      // JMcompressed = project_to + v * (JMboundary - project_to);\n      JMcompressed = float2(JMh.x,v*JMboundary.y);\n    \}\n\n    // Diagnostic outputs\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 18)\n    \{\n      // return float3(interpolatedCompressionFuncParams.y, interpolatedCompressionFuncParams.z, JMh.z);\n      return float3(JMh.x, JMboundary.y, JMh.z);\n    \}\n    // actual output\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // M Max data generated via an external Nukescript at a J value of 100\n    float LocusLimitMTable_data\[]=\n    \{\n      244.8230133, 245.4952393, 246.4431458, 247.1381531, 247.2368927, 246.8459778, 245.7083588, 244.2591095, 242.5463409, 240.4208374, 238.0180511, 235.4039917, 233.010849, 230.4004669, 227.8723602, 225.2279968, 222.7197876, 214.8562622, 206.1778564, 198.0664215, 190.9799347, 184.005127, 177.7472992, 172.2332611, 166.6447754, 161.64534, 156.9872284, 152.6203003, 148.3236084, 144.2987976, 140.8540192, 137.4315033, 134.3281555, 131.2306366, 128.3477631, 125.8098145, 123.1305542, 120.5120163, 118.3302231, 116.127861, 114.0526428, 112.1633072, 110.2943344, 108.4250336, 106.711853, 105.188797, 103.6860809, 102.2319641, 100.8348923, 99.51873779, 98.26163483, 97.04810333, 95.90451813, 94.84623718, 93.86389923, 92.9352951, 92.03639984, 91.15013885, 90.27630615, 89.43255615, 88.63536072, 87.8986969, 87.23329163, 86.63896942, 86.09989166, 85.60071564, 85.12715912, 84.66781616, 84.21458435, 83.76491547, 83.30849457, 82.86478424, 82.46378326, 82.11483002, 81.82078552, 81.58016968, 81.37005615, 81.18525696, 81.01979065, 80.86772156, 80.72546387, 80.59381104, 80.48122406, 80.40287018, 80.33755493, 80.30010986, 80.28891754, 80.28807831, 80.33933258, 80.44513702, 80.57379913, 80.71469879, 80.86810303, 81.03874207, 81.23072052, 81.44044495, 81.6555481, 81.901474, 82.20778656, 82.67211151, 83.1408844, 83.62628174, 84.0898056, 84.53721619, 84.99518585, 85.49137878, 86.03423309, 86.58794403, 87.16802979, 87.72124481, 88.51965332, 89.35781097, 90.16739655, 90.94639587, 91.75927734, 92.65882111, 93.6033783, 94.64561462, 95.68405914, 96.84765625, 97.98625183, 99.09587097, 100.2806396, 101.5832748, 103.0694122, 104.6378632, 106.2420197, 107.8503952, 109.5214844, 111.3000031, 113.1901169, 115.1414337, 117.1432114, 119.3193054, 121.7141724, 124.2319031, 126.4584961, 128.9876556, 131.6906891, 134.7160034, 137.8343048, 140.7224121, 143.7820892, 147.23909, 150.6812439, 154.0381317, 157.1765747, 160.5133972, 164.2957306, 168.1366272, 171.8247986, 175.4206543, 179.2828827, 182.0374146, 185.0783844, 188.2106171, 190.9611206, 193.3639221, 195.5132294, 197.58255, 199.4234161, 201.3786011, 203.1474609, 205.016037, 206.6236725, 208.1813812, 209.8205719, 211.2774353, 212.8192749, 214.4571686, 215.6442261, 216.4818726, 217.1617279, 217.7372131, 218.2023926, 218.4073486, 218.4278564, 217.6643677, 216.4666748, 215.1212463, 213.8158264, 212.5012817, 210.8331757, 208.8956146, 206.9006958, 204.9239197, 203.0310059, 201.2084045, 199.3484344, 197.3464355, 195.217453, 193.0449677, 190.9578705, 188.9528656, 187.0009918, 185.0068817, 182.9402924, 180.8367767, 178.7057037, 176.5325165, 174.445282, 172.4908905, 170.5744934, 168.5490723, 166.459259, 164.4333649, 162.5092621, 160.4579468, 158.491806, 156.6880035, 155.0045624, 153.295166, 151.4545441, 149.5910492, 147.7821808, 146.4078522, 144.8022614, 143.2662506, 141.8236542, 140.5029602, 139.225174, 137.8959045, 136.4792175, 135.0780334, 133.7389374, 132.7613525, 131.6787109, 130.6356354, 129.64328, 128.7269897, 127.8450623, 126.9439697, 126.0015182, 125.0760727, 124.1718826, 123.4704056, 122.8062363, 122.1408768, 121.501358, 120.9004822, 120.3225555, 119.7514191, 119.2011871, 118.7055511, 118.2950592, 117.9416199, 117.5793762, 117.2029953, 116.8356552, 116.4874039, 116.1693954, 115.9030762, 115.6935577, 115.5213852, 115.3659363, 115.2032318, 115.0445251, 114.9317932, 114.8815384, 114.8605118, 114.8510284, 114.8482819, 114.848465, 114.8521805, 114.8999329, 115.0081787, 115.1483612, 115.2983322, 115.511528, 115.7195816, 115.9448853, 116.2098999, 116.5264893, 116.8126144, 117.1579666, 117.5379944, 117.9048004, 118.3263168, 118.8006821, 119.2988586, 119.8310318, 120.3776703, 121.0383987, 121.6810684, 122.4489899, 123.207077, 124.071022, 124.9082108, 125.74823, 126.6865311, 127.4425888, 127.8552094, 128.1067963, 128.3630676, 128.6606598, 128.9203491, 129.2632141, 129.708252, 130.1131287, 130.5647278, 130.9923553, 131.5979462, 132.2623444, 132.8651428, 133.4651947, 134.1470337, 134.8683624, 135.683609, 136.6136017, 137.5203552, 138.3826599, 139.2931976, 140.2762299, 141.2150574, 142.3930054, 143.7060547, 145.0472565, 146.3404083, 147.6144257, 148.9406586, 150.3545532, 151.8509674, 153.4246826, 155.0567017, 156.7265472, 158.4546509, 160.2428131, 162.1348267, 164.1415863, 166.2302551, 168.4024506, 170.5583649, 172.6457672, 174.9460449, 177.2792664, 179.6472473, 182.1867218, 184.5882721, 187.3068848, 189.8807373, 192.5116577, 195.5551453, 198.5196381, 201.3429413, 203.941452, 206.8439484, 209.5599213, 212.4866943, 215.0750885, 217.929306, 220.6668701, 223.364151, 226.2115479, 228.9524536, 231.5583954, 234.405304, 237.0275879, 239.5091705, 242.0047455, 242.0177155\n    \};\n\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    XYZ_to_AP1.setArray(XYZ_to_AP1_ACES_matrix_data);\n    AP1_to_XYZ = XYZ_to_AP1.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n\n    // LocusLimitMTable = LocusLimitMTable_data;\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      LocusLimitMTable\[i] = LocusLimitMTable_data\[i];\n    \}\n\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n  // Cusp table for limiting gamut\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n    \n    // Cusp table for AP1 gamut\n    \{\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsortedAP1\[i] = AP1_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsortedAP1\[i].z <  gamutCuspTableUnsortedAP1\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTableAP1\[i] = gamutCuspTableUnsortedAP1\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n  \}\n\n\n\n\n\}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    SampleType(extra) sourceExtra = src();\n    float3 extraRGB(sourceExtra.x, sourceExtra.y, sourceExtra.z);\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      if( invert )\n      \{\n        diagnostic =  JMh_to_input_RGB(srcRGB);\n      \}\n      else\n      \{\n        diagnostic =  JMh;\n      \}\n\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    else if (diagnosticMode == 14)\n    \{\n      // output gamut cusp\n      diagnostic = float3(cuspFromTable(srcRGB.z).x, cuspFromTable(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 15)\n    \{\n      // output AP1 cusp\n      diagnostic = float3(cuspFromTableAP1(srcRGB.z).x, cuspFromTableAP1(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 16)\n    \{\n      // output Locus cusp\n      diagnostic = float3(cuspFromTableLocus(srcRGB.z).x, cuspFromTableLocus(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 17)\n    \{\n      // output Locus boundry\n      diagnostic = getLocusBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 18)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0  );\n    \}\n\n\n\n\n    // extra modes to allow for easier breakout of the order of events.\n    // modes starting with 100\n\n    else if (diagnosticMode == 100)\n    \{\n      // output input as luminanceXYZ\n      diagnostic = input_RGB_to_JMh(srcRGB);\n    \}\n\n    else if (diagnosticMode == 101)\n    \{\n      // convert luminanceXYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n\n    else if (diagnosticMode == 102)\n    \{\n      // JMh to tonemappedJMh\n      diagnostic = forwardTonescale(srcRGB, extraRGB);\n    \}\n\n    else if (diagnosticMode == 103)\n    \{\n      // JMh to gamut compressed JMh\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    else if (diagnosticMode == 104)\n    \{\n      // JMh to luminance XYZ\n      diagnostic = JMh_to_XYZ( srcRGB, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n\n    else if (diagnosticMode == 105)\n    \{\n      // luminance XYZ to luminanceRGB\n      diagnostic = JMh_to_output_RGB(srcRGB);\n    \}\n\n    else if (diagnosticMode == 106)\n    \{\n      // luminanceRGB to output RGB\n      diagnostic = luminanceToEncoding3( encodingOut, srcRGB);\n    \}\n\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_simpleCompressMode {{parent.BlinkScript1_DRT_CAM_Kernel_simpleCompressMode}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_Locuscompressmode {{parent.BlinkScript1_DRT_CAM_Kernel_Locuscompressmode}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -201
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
push $N12ad4600
Dot {
 name Dot27
 xpos -659
 ypos 637
}
set N948c9600 [stack 0]
Dot {
 name Dot25
 xpos -659
 ypos 1010
}
push $N948c9600
Group {
 name DRT_CAM1
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos -488
 ypos 604
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {6 BlinkScript1_DRT_CAM_Kernel_simpleCompressMode l simpleCompressMode -STARTLINE}
 BlinkScript1_DRT_CAM_Kernel_simpleCompressMode true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit P3-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 1000
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.7 1.2 1.7 1}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_AP1compressmode l AP1compressmode T BlinkScript1.DRT_CAM_Kernel_AP1compressmode}
 addUserKnob {6 BlinkScript1_DRT_CAM_Kernel_Locuscompressmode l Locuscompressmode +STARTLINE}
 BlinkScript1_DRT_CAM_Kernel_Locuscompressmode true
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.2 1.4 {compressionFuncParamsR.g} 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {{compressionFuncParamsR.r} 1.21 {compressionFuncParamsY.g} 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {{compressionFuncParamsR.r} 1.3 {compressionFuncParamsG.g} 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {{compressionFuncParamsR.r} 1.9 {compressionFuncParamsC.g} 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {{compressionFuncParamsR.r} 1.2 {compressionFuncParamsB.g} 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {{compressionFuncParamsR.r} 1.23 {compressionFuncParamsM.g} 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out sRGB
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out P3-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name extra
  xpos -1244
  ypos -259
  number 1
 }
 Reformat {
  inputs 0
  name Reformat1
  xpos -1120
  ypos -264
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input1]"}}
  name Switch1
  xpos -1120
  ypos -195
 }
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  inputs 2
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v038.blink
  recompileCount 2561
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b01ab31261204a9edd5ee1cd13bdd2e603d7a9a00100add44c8b8f3d5ce677ab 3 \"src\" Read Point \"extra\" Read Point \"dst\" Write Point 74 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"simpleCompressMode\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"AP1compressmode\" Bool 1 AA== \"Locuscompressmode\" Bool 1 AA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 74 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"simpleCompressMode\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"AP1compressmode\" 1 1 \"Locuscompressmode\" 1 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 52 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTableUnsortedAP1\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTableAP1\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LocusLimitMTable\" Float 1 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> extra; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n    bool simpleCompressMode;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n    bool AP1compressmode;\n    bool Locuscompressmode;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    float3x3 AP1_to_XYZ;\n    float3x3 XYZ_to_AP1;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 gamutCuspTableUnsortedAP1\[360];\n    float3 gamutCuspTableAP1\[360];\n    float3 cgamutCuspTable\[360];\n    float LocusLimitMTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n\n    // switch to treat incoming data as luminanceXYZ when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      luminanceXYZ = JMh;\n    \}\n\n\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    // return luminanceRGB when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      return luminanceRGB;\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n  // convert linear RGB values with the AP1 primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 AP1_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(AP1_to_XYZ, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n    float2 cuspFromTableAP1(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTableAP1\[0].z )\n    \{\n      lo = gamutCuspTableAP1\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTableAP1\[0];\n    \}\n    else if( h >= gamutCuspTableAP1\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTableAP1\[gamutCuspTableSize-1];\n      hi = gamutCuspTableAP1\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTableAP1\[i].z )\n        \{\n          lo = gamutCuspTableAP1\[i-1];\n          hi = gamutCuspTableAP1\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n\n  float2 cuspFromTableLocus(float h)\n  \{\n\n    // float lo;\n    // float hi;\n\n    // if( h <= LocusLimitMTable\[0] )\n    // \{\n    //   lo = LocusLimitMTable\[gamutCuspTableSize-1];\n    //   lo = lo-360.0f;\n    //   hi = LocusLimitMTable\[0];\n    // \}\n    // else if( h >= LocusLimitMTable\[gamutCuspTableSize-1] )\n    // \{\n    //   lo = LocusLimitMTable\[gamutCuspTableSize-1];\n    //   hi = LocusLimitMTable\[0];\n    //   hi = hi+360.f;\n    // \}\n    // else\n    // \{\n    //   for(int i = 1; i < gamutCuspTableSize; ++i)\n    //   \{\n    //     if( h <= LocusLimitMTable\[i] )\n    //     \{\n    //       lo = LocusLimitMTable\[i-1];\n    //       hi = LocusLimitMTable\[i];\n    //       break;\n    //     \}\n    //   \}\n    // \}\n\n    // float t = (h - lo) / (hi - lo);\n\n    float cuspJ = 69;\n    // float cuspM = lerp(lo, hi, t);\n    float cuspM = LocusLimitMTable\[int(h)];\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (simpleCompressMode)\n    \{\n      if (!invert)\n      \{\n        M =  JMh.y * ( JMh.x / origJ);\n      \}\n      else\n      \{\n        M =  JMh.y * ( JMh.x / origJ);\n      \}\n      return M;\n    \}\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n      M = min(M,JMh.y);\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6 || diagnosticMode == 100)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n  float3 getLocusBoundry(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float2 cuspLocus = cuspFromTableLocus(h);\n    float cuspTarget100 = cuspLocus.y;\n    // 0.86 has been eyeballed to match the locus in Nuke\n    float cuspTarget = cuspTarget100 * pow((Jmh.x/100.0f),0.86f);\n    float difference =  cuspLocus.y / cuspTarget;\n    return float3(Jmh.x,cuspTarget,Jmh.z);\n  \}\n\n\n  float4 getCompressionFuncParams(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float angleR = 20.0f;\n    float angleY = 102.0f;\n    float angleG = 146.0f;\n    float angleC = 193.0f;\n    float angleB = 259.0f;\n    float angleM = 342.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if(AP1compressmode)\n    \{\n        float2 cuspAP1 = cuspFromTableAP1(h);\n        float2 cuspTarget = cuspFromTable(h);\n        float difference =  cuspAP1.y / cuspTarget.y;\n        return float4(0.2,difference,difference,1.0);\n    \}\n    if(Locuscompressmode)\n    \{\n        // float2 cuspLocus = cuspFromTableLocus(h);\n        float cuspTarget = cuspFromTable(h).y;\n        float locusMax = getLocusBoundry(Jmh).y;\n        // float cuspTarget = cuspTarget100 * (Jmh.x/100.0f);\n        float difference =  locusMax / Jmh.y;\n        // float difference = Jmh.y;\n        return float4(compressionFuncParams.x,difference,difference,compressionFuncParams.w);\n        // return float4(compressionFuncParams.x,locusMax,Jmh.y,compressionFuncParams.w);\n    \}\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    // float2 project_to = float2(project_from.x, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n    // float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_from, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMh.x,JMboundary.y,JMh.z));\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      // JMcompressed = project_to + v * (JMboundary - project_to);\n      JMcompressed = float2(JMh.x,v*JMboundary.y);\n    \}\n\n    // Diagnostic outputs\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 18)\n    \{\n      // return float3(interpolatedCompressionFuncParams.y, interpolatedCompressionFuncParams.z, JMh.z);\n      return float3(JMh.x, JMboundary.y, JMh.z);\n    \}\n    // actual output\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // M Max data generated via an external Nukescript at a J value of 100\n    float LocusLimitMTable_data\[]=\n    \{\n      244.8230133, 245.4952393, 246.4431458, 247.1381531, 247.2368927, 246.8459778, 245.7083588, 244.2591095, 242.5463409, 240.4208374, 238.0180511, 235.4039917, 233.010849, 230.4004669, 227.8723602, 225.2279968, 222.7197876, 214.8562622, 206.1778564, 198.0664215, 190.9799347, 184.005127, 177.7472992, 172.2332611, 166.6447754, 161.64534, 156.9872284, 152.6203003, 148.3236084, 144.2987976, 140.8540192, 137.4315033, 134.3281555, 131.2306366, 128.3477631, 125.8098145, 123.1305542, 120.5120163, 118.3302231, 116.127861, 114.0526428, 112.1633072, 110.2943344, 108.4250336, 106.711853, 105.188797, 103.6860809, 102.2319641, 100.8348923, 99.51873779, 98.26163483, 97.04810333, 95.90451813, 94.84623718, 93.86389923, 92.9352951, 92.03639984, 91.15013885, 90.27630615, 89.43255615, 88.63536072, 87.8986969, 87.23329163, 86.63896942, 86.09989166, 85.60071564, 85.12715912, 84.66781616, 84.21458435, 83.76491547, 83.30849457, 82.86478424, 82.46378326, 82.11483002, 81.82078552, 81.58016968, 81.37005615, 81.18525696, 81.01979065, 80.86772156, 80.72546387, 80.59381104, 80.48122406, 80.40287018, 80.33755493, 80.30010986, 80.28891754, 80.28807831, 80.33933258, 80.44513702, 80.57379913, 80.71469879, 80.86810303, 81.03874207, 81.23072052, 81.44044495, 81.6555481, 81.901474, 82.20778656, 82.67211151, 83.1408844, 83.62628174, 84.0898056, 84.53721619, 84.99518585, 85.49137878, 86.03423309, 86.58794403, 87.16802979, 87.72124481, 88.51965332, 89.35781097, 90.16739655, 90.94639587, 91.75927734, 92.65882111, 93.6033783, 94.64561462, 95.68405914, 96.84765625, 97.98625183, 99.09587097, 100.2806396, 101.5832748, 103.0694122, 104.6378632, 106.2420197, 107.8503952, 109.5214844, 111.3000031, 113.1901169, 115.1414337, 117.1432114, 119.3193054, 121.7141724, 124.2319031, 126.4584961, 128.9876556, 131.6906891, 134.7160034, 137.8343048, 140.7224121, 143.7820892, 147.23909, 150.6812439, 154.0381317, 157.1765747, 160.5133972, 164.2957306, 168.1366272, 171.8247986, 175.4206543, 179.2828827, 182.0374146, 185.0783844, 188.2106171, 190.9611206, 193.3639221, 195.5132294, 197.58255, 199.4234161, 201.3786011, 203.1474609, 205.016037, 206.6236725, 208.1813812, 209.8205719, 211.2774353, 212.8192749, 214.4571686, 215.6442261, 216.4818726, 217.1617279, 217.7372131, 218.2023926, 218.4073486, 218.4278564, 217.6643677, 216.4666748, 215.1212463, 213.8158264, 212.5012817, 210.8331757, 208.8956146, 206.9006958, 204.9239197, 203.0310059, 201.2084045, 199.3484344, 197.3464355, 195.217453, 193.0449677, 190.9578705, 188.9528656, 187.0009918, 185.0068817, 182.9402924, 180.8367767, 178.7057037, 176.5325165, 174.445282, 172.4908905, 170.5744934, 168.5490723, 166.459259, 164.4333649, 162.5092621, 160.4579468, 158.491806, 156.6880035, 155.0045624, 153.295166, 151.4545441, 149.5910492, 147.7821808, 146.4078522, 144.8022614, 143.2662506, 141.8236542, 140.5029602, 139.225174, 137.8959045, 136.4792175, 135.0780334, 133.7389374, 132.7613525, 131.6787109, 130.6356354, 129.64328, 128.7269897, 127.8450623, 126.9439697, 126.0015182, 125.0760727, 124.1718826, 123.4704056, 122.8062363, 122.1408768, 121.501358, 120.9004822, 120.3225555, 119.7514191, 119.2011871, 118.7055511, 118.2950592, 117.9416199, 117.5793762, 117.2029953, 116.8356552, 116.4874039, 116.1693954, 115.9030762, 115.6935577, 115.5213852, 115.3659363, 115.2032318, 115.0445251, 114.9317932, 114.8815384, 114.8605118, 114.8510284, 114.8482819, 114.848465, 114.8521805, 114.8999329, 115.0081787, 115.1483612, 115.2983322, 115.511528, 115.7195816, 115.9448853, 116.2098999, 116.5264893, 116.8126144, 117.1579666, 117.5379944, 117.9048004, 118.3263168, 118.8006821, 119.2988586, 119.8310318, 120.3776703, 121.0383987, 121.6810684, 122.4489899, 123.207077, 124.071022, 124.9082108, 125.74823, 126.6865311, 127.4425888, 127.8552094, 128.1067963, 128.3630676, 128.6606598, 128.9203491, 129.2632141, 129.708252, 130.1131287, 130.5647278, 130.9923553, 131.5979462, 132.2623444, 132.8651428, 133.4651947, 134.1470337, 134.8683624, 135.683609, 136.6136017, 137.5203552, 138.3826599, 139.2931976, 140.2762299, 141.2150574, 142.3930054, 143.7060547, 145.0472565, 146.3404083, 147.6144257, 148.9406586, 150.3545532, 151.8509674, 153.4246826, 155.0567017, 156.7265472, 158.4546509, 160.2428131, 162.1348267, 164.1415863, 166.2302551, 168.4024506, 170.5583649, 172.6457672, 174.9460449, 177.2792664, 179.6472473, 182.1867218, 184.5882721, 187.3068848, 189.8807373, 192.5116577, 195.5551453, 198.5196381, 201.3429413, 203.941452, 206.8439484, 209.5599213, 212.4866943, 215.0750885, 217.929306, 220.6668701, 223.364151, 226.2115479, 228.9524536, 231.5583954, 234.405304, 237.0275879, 239.5091705, 242.0047455, 242.0177155\n    \};\n\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    XYZ_to_AP1.setArray(XYZ_to_AP1_ACES_matrix_data);\n    AP1_to_XYZ = XYZ_to_AP1.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n\n    // LocusLimitMTable = LocusLimitMTable_data;\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      LocusLimitMTable\[i] = LocusLimitMTable_data\[i];\n    \}\n\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n  // Cusp table for limiting gamut\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n    \n    // Cusp table for AP1 gamut\n    \{\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsortedAP1\[i] = AP1_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsortedAP1\[i].z <  gamutCuspTableUnsortedAP1\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTableAP1\[i] = gamutCuspTableUnsortedAP1\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n  \}\n\n\n\n\n\}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    SampleType(extra) sourceExtra = src();\n    float3 extraRGB(sourceExtra.x, sourceExtra.y, sourceExtra.z);\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      if( invert )\n      \{\n        diagnostic =  JMh_to_input_RGB(srcRGB);\n      \}\n      else\n      \{\n        diagnostic =  JMh;\n      \}\n\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    else if (diagnosticMode == 14)\n    \{\n      // output gamut cusp\n      diagnostic = float3(cuspFromTable(srcRGB.z).x, cuspFromTable(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 15)\n    \{\n      // output AP1 cusp\n      diagnostic = float3(cuspFromTableAP1(srcRGB.z).x, cuspFromTableAP1(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 16)\n    \{\n      // output Locus cusp\n      diagnostic = float3(cuspFromTableLocus(srcRGB.z).x, cuspFromTableLocus(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 17)\n    \{\n      // output Locus boundry\n      diagnostic = getLocusBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 18)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0  );\n    \}\n\n\n\n\n    // extra modes to allow for easier breakout of the order of events.\n    // modes starting with 100\n\n    else if (diagnosticMode == 100)\n    \{\n      // output input as luminanceXYZ\n      diagnostic = input_RGB_to_JMh(srcRGB);\n    \}\n\n    else if (diagnosticMode == 101)\n    \{\n      // convert luminanceXYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n\n    else if (diagnosticMode == 102)\n    \{\n      // JMh to tonemappedJMh\n      diagnostic = forwardTonescale(srcRGB, extraRGB);\n    \}\n\n    else if (diagnosticMode == 103)\n    \{\n      // JMh to gamut compressed JMh\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    else if (diagnosticMode == 104)\n    \{\n      // JMh to luminance XYZ\n      diagnostic = JMh_to_XYZ( srcRGB, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n\n    else if (diagnosticMode == 105)\n    \{\n      // luminance XYZ to luminanceRGB\n      diagnostic = JMh_to_output_RGB(srcRGB);\n    \}\n\n    else if (diagnosticMode == 106)\n    \{\n      // luminanceRGB to output RGB\n      diagnostic = luminanceToEncoding3( encodingOut, srcRGB);\n    \}\n\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_simpleCompressMode {{parent.BlinkScript1_DRT_CAM_Kernel_simpleCompressMode}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_Locuscompressmode {{parent.BlinkScript1_DRT_CAM_Kernel_Locuscompressmode}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 100
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -201
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Group {
 name DRT_CAM2
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos -488
 ypos 806
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {6 BlinkScript1_DRT_CAM_Kernel_simpleCompressMode l simpleCompressMode -STARTLINE}
 BlinkScript1_DRT_CAM_Kernel_simpleCompressMode true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit P3-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 1000
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.7 1.2 1.7 1}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_AP1compressmode l AP1compressmode T BlinkScript1.DRT_CAM_Kernel_AP1compressmode}
 addUserKnob {6 BlinkScript1_DRT_CAM_Kernel_Locuscompressmode l Locuscompressmode +STARTLINE}
 BlinkScript1_DRT_CAM_Kernel_Locuscompressmode true
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.2 1.4 {compressionFuncParamsR.g} 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {{compressionFuncParamsR.r} 1.21 {compressionFuncParamsY.g} 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {{compressionFuncParamsR.r} 1.3 {compressionFuncParamsG.g} 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {{compressionFuncParamsR.r} 1.9 {compressionFuncParamsC.g} 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {{compressionFuncParamsR.r} 1.2 {compressionFuncParamsB.g} 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {{compressionFuncParamsR.r} 1.23 {compressionFuncParamsM.g} 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out sRGB
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out P3-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name extra
  xpos -1244
  ypos -259
  number 1
 }
 Reformat {
  inputs 0
  name Reformat1
  xpos -1120
  ypos -264
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input1]"}}
  name Switch1
  xpos -1120
  ypos -195
 }
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  inputs 2
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v038.blink
  recompileCount 2561
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b01ab31261204a9edd5ee1cd13bdd2e603d7a9a00100add44c8b8f3d5ce677ab 3 \"src\" Read Point \"extra\" Read Point \"dst\" Write Point 74 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"simpleCompressMode\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"AP1compressmode\" Bool 1 AA== \"Locuscompressmode\" Bool 1 AA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 74 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"simpleCompressMode\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"AP1compressmode\" 1 1 \"Locuscompressmode\" 1 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 52 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTableUnsortedAP1\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTableAP1\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LocusLimitMTable\" Float 1 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> extra; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n    bool simpleCompressMode;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n    bool AP1compressmode;\n    bool Locuscompressmode;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    float3x3 AP1_to_XYZ;\n    float3x3 XYZ_to_AP1;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 gamutCuspTableUnsortedAP1\[360];\n    float3 gamutCuspTableAP1\[360];\n    float3 cgamutCuspTable\[360];\n    float LocusLimitMTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n\n    // switch to treat incoming data as luminanceXYZ when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      luminanceXYZ = JMh;\n    \}\n\n\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    // return luminanceRGB when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      return luminanceRGB;\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n  // convert linear RGB values with the AP1 primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 AP1_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(AP1_to_XYZ, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n    float2 cuspFromTableAP1(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTableAP1\[0].z )\n    \{\n      lo = gamutCuspTableAP1\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTableAP1\[0];\n    \}\n    else if( h >= gamutCuspTableAP1\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTableAP1\[gamutCuspTableSize-1];\n      hi = gamutCuspTableAP1\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTableAP1\[i].z )\n        \{\n          lo = gamutCuspTableAP1\[i-1];\n          hi = gamutCuspTableAP1\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n\n  float2 cuspFromTableLocus(float h)\n  \{\n\n    // float lo;\n    // float hi;\n\n    // if( h <= LocusLimitMTable\[0] )\n    // \{\n    //   lo = LocusLimitMTable\[gamutCuspTableSize-1];\n    //   lo = lo-360.0f;\n    //   hi = LocusLimitMTable\[0];\n    // \}\n    // else if( h >= LocusLimitMTable\[gamutCuspTableSize-1] )\n    // \{\n    //   lo = LocusLimitMTable\[gamutCuspTableSize-1];\n    //   hi = LocusLimitMTable\[0];\n    //   hi = hi+360.f;\n    // \}\n    // else\n    // \{\n    //   for(int i = 1; i < gamutCuspTableSize; ++i)\n    //   \{\n    //     if( h <= LocusLimitMTable\[i] )\n    //     \{\n    //       lo = LocusLimitMTable\[i-1];\n    //       hi = LocusLimitMTable\[i];\n    //       break;\n    //     \}\n    //   \}\n    // \}\n\n    // float t = (h - lo) / (hi - lo);\n\n    float cuspJ = 69;\n    // float cuspM = lerp(lo, hi, t);\n    float cuspM = LocusLimitMTable\[int(h)];\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (simpleCompressMode)\n    \{\n      if (!invert)\n      \{\n        M =  JMh.y * ( JMh.x / origJ);\n      \}\n      else\n      \{\n        M =  JMh.y * ( JMh.x / origJ);\n      \}\n      return M;\n    \}\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n      M = min(M,JMh.y);\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6 || diagnosticMode == 100)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n  float3 getLocusBoundry(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float2 cuspLocus = cuspFromTableLocus(h);\n    float cuspTarget100 = cuspLocus.y;\n    // 0.86 has been eyeballed to match the locus in Nuke\n    float cuspTarget = cuspTarget100 * pow((Jmh.x/100.0f),0.86f);\n    float difference =  cuspLocus.y / cuspTarget;\n    return float3(Jmh.x,cuspTarget,Jmh.z);\n  \}\n\n\n  float4 getCompressionFuncParams(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float angleR = 20.0f;\n    float angleY = 102.0f;\n    float angleG = 146.0f;\n    float angleC = 193.0f;\n    float angleB = 259.0f;\n    float angleM = 342.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if(AP1compressmode)\n    \{\n        float2 cuspAP1 = cuspFromTableAP1(h);\n        float2 cuspTarget = cuspFromTable(h);\n        float difference =  cuspAP1.y / cuspTarget.y;\n        return float4(0.2,difference,difference,1.0);\n    \}\n    if(Locuscompressmode)\n    \{\n        // float2 cuspLocus = cuspFromTableLocus(h);\n        float cuspTarget = cuspFromTable(h).y;\n        float locusMax = getLocusBoundry(Jmh).y;\n        // float cuspTarget = cuspTarget100 * (Jmh.x/100.0f);\n        float difference =  locusMax / Jmh.y;\n        // float difference = Jmh.y;\n        return float4(compressionFuncParams.x,difference,difference,compressionFuncParams.w);\n        // return float4(compressionFuncParams.x,locusMax,Jmh.y,compressionFuncParams.w);\n    \}\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    // float2 project_to = float2(project_from.x, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n    // float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_from, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMh.x,JMboundary.y,JMh.z));\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      // JMcompressed = project_to + v * (JMboundary - project_to);\n      JMcompressed = float2(JMh.x,v*JMboundary.y);\n    \}\n\n    // Diagnostic outputs\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 18)\n    \{\n      // return float3(interpolatedCompressionFuncParams.y, interpolatedCompressionFuncParams.z, JMh.z);\n      return float3(JMh.x, JMboundary.y, JMh.z);\n    \}\n    // actual output\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // M Max data generated via an external Nukescript at a J value of 100\n    float LocusLimitMTable_data\[]=\n    \{\n      244.8230133, 245.4952393, 246.4431458, 247.1381531, 247.2368927, 246.8459778, 245.7083588, 244.2591095, 242.5463409, 240.4208374, 238.0180511, 235.4039917, 233.010849, 230.4004669, 227.8723602, 225.2279968, 222.7197876, 214.8562622, 206.1778564, 198.0664215, 190.9799347, 184.005127, 177.7472992, 172.2332611, 166.6447754, 161.64534, 156.9872284, 152.6203003, 148.3236084, 144.2987976, 140.8540192, 137.4315033, 134.3281555, 131.2306366, 128.3477631, 125.8098145, 123.1305542, 120.5120163, 118.3302231, 116.127861, 114.0526428, 112.1633072, 110.2943344, 108.4250336, 106.711853, 105.188797, 103.6860809, 102.2319641, 100.8348923, 99.51873779, 98.26163483, 97.04810333, 95.90451813, 94.84623718, 93.86389923, 92.9352951, 92.03639984, 91.15013885, 90.27630615, 89.43255615, 88.63536072, 87.8986969, 87.23329163, 86.63896942, 86.09989166, 85.60071564, 85.12715912, 84.66781616, 84.21458435, 83.76491547, 83.30849457, 82.86478424, 82.46378326, 82.11483002, 81.82078552, 81.58016968, 81.37005615, 81.18525696, 81.01979065, 80.86772156, 80.72546387, 80.59381104, 80.48122406, 80.40287018, 80.33755493, 80.30010986, 80.28891754, 80.28807831, 80.33933258, 80.44513702, 80.57379913, 80.71469879, 80.86810303, 81.03874207, 81.23072052, 81.44044495, 81.6555481, 81.901474, 82.20778656, 82.67211151, 83.1408844, 83.62628174, 84.0898056, 84.53721619, 84.99518585, 85.49137878, 86.03423309, 86.58794403, 87.16802979, 87.72124481, 88.51965332, 89.35781097, 90.16739655, 90.94639587, 91.75927734, 92.65882111, 93.6033783, 94.64561462, 95.68405914, 96.84765625, 97.98625183, 99.09587097, 100.2806396, 101.5832748, 103.0694122, 104.6378632, 106.2420197, 107.8503952, 109.5214844, 111.3000031, 113.1901169, 115.1414337, 117.1432114, 119.3193054, 121.7141724, 124.2319031, 126.4584961, 128.9876556, 131.6906891, 134.7160034, 137.8343048, 140.7224121, 143.7820892, 147.23909, 150.6812439, 154.0381317, 157.1765747, 160.5133972, 164.2957306, 168.1366272, 171.8247986, 175.4206543, 179.2828827, 182.0374146, 185.0783844, 188.2106171, 190.9611206, 193.3639221, 195.5132294, 197.58255, 199.4234161, 201.3786011, 203.1474609, 205.016037, 206.6236725, 208.1813812, 209.8205719, 211.2774353, 212.8192749, 214.4571686, 215.6442261, 216.4818726, 217.1617279, 217.7372131, 218.2023926, 218.4073486, 218.4278564, 217.6643677, 216.4666748, 215.1212463, 213.8158264, 212.5012817, 210.8331757, 208.8956146, 206.9006958, 204.9239197, 203.0310059, 201.2084045, 199.3484344, 197.3464355, 195.217453, 193.0449677, 190.9578705, 188.9528656, 187.0009918, 185.0068817, 182.9402924, 180.8367767, 178.7057037, 176.5325165, 174.445282, 172.4908905, 170.5744934, 168.5490723, 166.459259, 164.4333649, 162.5092621, 160.4579468, 158.491806, 156.6880035, 155.0045624, 153.295166, 151.4545441, 149.5910492, 147.7821808, 146.4078522, 144.8022614, 143.2662506, 141.8236542, 140.5029602, 139.225174, 137.8959045, 136.4792175, 135.0780334, 133.7389374, 132.7613525, 131.6787109, 130.6356354, 129.64328, 128.7269897, 127.8450623, 126.9439697, 126.0015182, 125.0760727, 124.1718826, 123.4704056, 122.8062363, 122.1408768, 121.501358, 120.9004822, 120.3225555, 119.7514191, 119.2011871, 118.7055511, 118.2950592, 117.9416199, 117.5793762, 117.2029953, 116.8356552, 116.4874039, 116.1693954, 115.9030762, 115.6935577, 115.5213852, 115.3659363, 115.2032318, 115.0445251, 114.9317932, 114.8815384, 114.8605118, 114.8510284, 114.8482819, 114.848465, 114.8521805, 114.8999329, 115.0081787, 115.1483612, 115.2983322, 115.511528, 115.7195816, 115.9448853, 116.2098999, 116.5264893, 116.8126144, 117.1579666, 117.5379944, 117.9048004, 118.3263168, 118.8006821, 119.2988586, 119.8310318, 120.3776703, 121.0383987, 121.6810684, 122.4489899, 123.207077, 124.071022, 124.9082108, 125.74823, 126.6865311, 127.4425888, 127.8552094, 128.1067963, 128.3630676, 128.6606598, 128.9203491, 129.2632141, 129.708252, 130.1131287, 130.5647278, 130.9923553, 131.5979462, 132.2623444, 132.8651428, 133.4651947, 134.1470337, 134.8683624, 135.683609, 136.6136017, 137.5203552, 138.3826599, 139.2931976, 140.2762299, 141.2150574, 142.3930054, 143.7060547, 145.0472565, 146.3404083, 147.6144257, 148.9406586, 150.3545532, 151.8509674, 153.4246826, 155.0567017, 156.7265472, 158.4546509, 160.2428131, 162.1348267, 164.1415863, 166.2302551, 168.4024506, 170.5583649, 172.6457672, 174.9460449, 177.2792664, 179.6472473, 182.1867218, 184.5882721, 187.3068848, 189.8807373, 192.5116577, 195.5551453, 198.5196381, 201.3429413, 203.941452, 206.8439484, 209.5599213, 212.4866943, 215.0750885, 217.929306, 220.6668701, 223.364151, 226.2115479, 228.9524536, 231.5583954, 234.405304, 237.0275879, 239.5091705, 242.0047455, 242.0177155\n    \};\n\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    XYZ_to_AP1.setArray(XYZ_to_AP1_ACES_matrix_data);\n    AP1_to_XYZ = XYZ_to_AP1.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n\n    // LocusLimitMTable = LocusLimitMTable_data;\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      LocusLimitMTable\[i] = LocusLimitMTable_data\[i];\n    \}\n\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n  // Cusp table for limiting gamut\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n    \n    // Cusp table for AP1 gamut\n    \{\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsortedAP1\[i] = AP1_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsortedAP1\[i].z <  gamutCuspTableUnsortedAP1\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTableAP1\[i] = gamutCuspTableUnsortedAP1\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n  \}\n\n\n\n\n\}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    SampleType(extra) sourceExtra = src();\n    float3 extraRGB(sourceExtra.x, sourceExtra.y, sourceExtra.z);\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      if( invert )\n      \{\n        diagnostic =  JMh_to_input_RGB(srcRGB);\n      \}\n      else\n      \{\n        diagnostic =  JMh;\n      \}\n\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    else if (diagnosticMode == 14)\n    \{\n      // output gamut cusp\n      diagnostic = float3(cuspFromTable(srcRGB.z).x, cuspFromTable(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 15)\n    \{\n      // output AP1 cusp\n      diagnostic = float3(cuspFromTableAP1(srcRGB.z).x, cuspFromTableAP1(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 16)\n    \{\n      // output Locus cusp\n      diagnostic = float3(cuspFromTableLocus(srcRGB.z).x, cuspFromTableLocus(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 17)\n    \{\n      // output Locus boundry\n      diagnostic = getLocusBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 18)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0  );\n    \}\n\n\n\n\n    // extra modes to allow for easier breakout of the order of events.\n    // modes starting with 100\n\n    else if (diagnosticMode == 100)\n    \{\n      // output input as luminanceXYZ\n      diagnostic = input_RGB_to_JMh(srcRGB);\n    \}\n\n    else if (diagnosticMode == 101)\n    \{\n      // convert luminanceXYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n\n    else if (diagnosticMode == 102)\n    \{\n      // JMh to tonemappedJMh\n      diagnostic = forwardTonescale(srcRGB, extraRGB);\n    \}\n\n    else if (diagnosticMode == 103)\n    \{\n      // JMh to gamut compressed JMh\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    else if (diagnosticMode == 104)\n    \{\n      // JMh to luminance XYZ\n      diagnostic = JMh_to_XYZ( srcRGB, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n\n    else if (diagnosticMode == 105)\n    \{\n      // luminance XYZ to luminanceRGB\n      diagnostic = JMh_to_output_RGB(srcRGB);\n    \}\n\n    else if (diagnosticMode == 106)\n    \{\n      // luminanceRGB to output RGB\n      diagnostic = luminanceToEncoding3( encodingOut, srcRGB);\n    \}\n\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_simpleCompressMode {{parent.BlinkScript1_DRT_CAM_Kernel_simpleCompressMode}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_Locuscompressmode {{parent.BlinkScript1_DRT_CAM_Kernel_Locuscompressmode}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 101
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -201
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
set N94906800 [stack 0]
Group {
 inputs 2
 name DRT_CAM3
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos -488
 ypos 977
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 addUserKnob {6 BlinkScript1_DRT_CAM_Kernel_simpleCompressMode l simpleCompressMode -STARTLINE}
 BlinkScript1_DRT_CAM_Kernel_simpleCompressMode true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit P3-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 1000
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.7 1.2 1.7 1}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_AP1compressmode l AP1compressmode T BlinkScript1.DRT_CAM_Kernel_AP1compressmode}
 addUserKnob {6 BlinkScript1_DRT_CAM_Kernel_Locuscompressmode l Locuscompressmode +STARTLINE}
 BlinkScript1_DRT_CAM_Kernel_Locuscompressmode true
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.2 1.4 {compressionFuncParamsR.g} 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {{compressionFuncParamsR.r} 1.21 {compressionFuncParamsY.g} 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {{compressionFuncParamsR.r} 1.3 {compressionFuncParamsG.g} 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {{compressionFuncParamsR.r} 1.9 {compressionFuncParamsC.g} 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {{compressionFuncParamsR.r} 1.2 {compressionFuncParamsB.g} 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {{compressionFuncParamsR.r} 1.23 {compressionFuncParamsM.g} 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out sRGB
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out P3-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name extra
  xpos -1244
  ypos -259
  number 1
 }
 Reformat {
  inputs 0
  name Reformat1
  xpos -1120
  ypos -264
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input1]"}}
  name Switch1
  xpos -1120
  ypos -195
 }
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  inputs 2
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v038.blink
  recompileCount 2561
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b01ab31261204a9edd5ee1cd13bdd2e603d7a9a00100add44c8b8f3d5ce677ab 3 \"src\" Read Point \"extra\" Read Point \"dst\" Write Point 74 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"simpleCompressMode\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"AP1compressmode\" Bool 1 AA== \"Locuscompressmode\" Bool 1 AA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 74 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"simpleCompressMode\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"AP1compressmode\" 1 1 \"Locuscompressmode\" 1 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 52 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTableUnsortedAP1\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTableAP1\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LocusLimitMTable\" Float 1 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> extra; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n    bool simpleCompressMode;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n    bool AP1compressmode;\n    bool Locuscompressmode;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    float3x3 AP1_to_XYZ;\n    float3x3 XYZ_to_AP1;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 gamutCuspTableUnsortedAP1\[360];\n    float3 gamutCuspTableAP1\[360];\n    float3 cgamutCuspTable\[360];\n    float LocusLimitMTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n\n    // switch to treat incoming data as luminanceXYZ when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      luminanceXYZ = JMh;\n    \}\n\n\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    // return luminanceRGB when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      return luminanceRGB;\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n  // convert linear RGB values with the AP1 primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 AP1_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(AP1_to_XYZ, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n    float2 cuspFromTableAP1(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTableAP1\[0].z )\n    \{\n      lo = gamutCuspTableAP1\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTableAP1\[0];\n    \}\n    else if( h >= gamutCuspTableAP1\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTableAP1\[gamutCuspTableSize-1];\n      hi = gamutCuspTableAP1\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTableAP1\[i].z )\n        \{\n          lo = gamutCuspTableAP1\[i-1];\n          hi = gamutCuspTableAP1\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n\n  float2 cuspFromTableLocus(float h)\n  \{\n\n    // float lo;\n    // float hi;\n\n    // if( h <= LocusLimitMTable\[0] )\n    // \{\n    //   lo = LocusLimitMTable\[gamutCuspTableSize-1];\n    //   lo = lo-360.0f;\n    //   hi = LocusLimitMTable\[0];\n    // \}\n    // else if( h >= LocusLimitMTable\[gamutCuspTableSize-1] )\n    // \{\n    //   lo = LocusLimitMTable\[gamutCuspTableSize-1];\n    //   hi = LocusLimitMTable\[0];\n    //   hi = hi+360.f;\n    // \}\n    // else\n    // \{\n    //   for(int i = 1; i < gamutCuspTableSize; ++i)\n    //   \{\n    //     if( h <= LocusLimitMTable\[i] )\n    //     \{\n    //       lo = LocusLimitMTable\[i-1];\n    //       hi = LocusLimitMTable\[i];\n    //       break;\n    //     \}\n    //   \}\n    // \}\n\n    // float t = (h - lo) / (hi - lo);\n\n    float cuspJ = 69;\n    // float cuspM = lerp(lo, hi, t);\n    float cuspM = LocusLimitMTable\[int(h)];\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (simpleCompressMode)\n    \{\n      if (!invert)\n      \{\n        M =  JMh.y * ( JMh.x / origJ);\n      \}\n      else\n      \{\n        M =  JMh.y * ( JMh.x / origJ);\n      \}\n      return M;\n    \}\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n      M = min(M,JMh.y);\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6 || diagnosticMode == 100)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n  float3 getLocusBoundry(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float2 cuspLocus = cuspFromTableLocus(h);\n    float cuspTarget100 = cuspLocus.y;\n    // 0.86 has been eyeballed to match the locus in Nuke\n    float cuspTarget = cuspTarget100 * pow((Jmh.x/100.0f),0.86f);\n    float difference =  cuspLocus.y / cuspTarget;\n    return float3(Jmh.x,cuspTarget,Jmh.z);\n  \}\n\n\n  float4 getCompressionFuncParams(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float angleR = 20.0f;\n    float angleY = 102.0f;\n    float angleG = 146.0f;\n    float angleC = 193.0f;\n    float angleB = 259.0f;\n    float angleM = 342.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if(AP1compressmode)\n    \{\n        float2 cuspAP1 = cuspFromTableAP1(h);\n        float2 cuspTarget = cuspFromTable(h);\n        float difference =  cuspAP1.y / cuspTarget.y;\n        return float4(0.2,difference,difference,1.0);\n    \}\n    if(Locuscompressmode)\n    \{\n        // float2 cuspLocus = cuspFromTableLocus(h);\n        float cuspTarget = cuspFromTable(h).y;\n        float locusMax = getLocusBoundry(Jmh).y;\n        // float cuspTarget = cuspTarget100 * (Jmh.x/100.0f);\n        float difference =  locusMax / Jmh.y;\n        // float difference = Jmh.y;\n        return float4(compressionFuncParams.x,difference,difference,compressionFuncParams.w);\n        // return float4(compressionFuncParams.x,locusMax,Jmh.y,compressionFuncParams.w);\n    \}\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    // float2 project_to = float2(project_from.x, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n    // float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_from, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMh.x,JMboundary.y,JMh.z));\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      // JMcompressed = project_to + v * (JMboundary - project_to);\n      JMcompressed = float2(JMh.x,v*JMboundary.y);\n    \}\n\n    // Diagnostic outputs\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 18)\n    \{\n      // return float3(interpolatedCompressionFuncParams.y, interpolatedCompressionFuncParams.z, JMh.z);\n      return float3(JMh.x, JMboundary.y, JMh.z);\n    \}\n    // actual output\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // M Max data generated via an external Nukescript at a J value of 100\n    float LocusLimitMTable_data\[]=\n    \{\n      244.8230133, 245.4952393, 246.4431458, 247.1381531, 247.2368927, 246.8459778, 245.7083588, 244.2591095, 242.5463409, 240.4208374, 238.0180511, 235.4039917, 233.010849, 230.4004669, 227.8723602, 225.2279968, 222.7197876, 214.8562622, 206.1778564, 198.0664215, 190.9799347, 184.005127, 177.7472992, 172.2332611, 166.6447754, 161.64534, 156.9872284, 152.6203003, 148.3236084, 144.2987976, 140.8540192, 137.4315033, 134.3281555, 131.2306366, 128.3477631, 125.8098145, 123.1305542, 120.5120163, 118.3302231, 116.127861, 114.0526428, 112.1633072, 110.2943344, 108.4250336, 106.711853, 105.188797, 103.6860809, 102.2319641, 100.8348923, 99.51873779, 98.26163483, 97.04810333, 95.90451813, 94.84623718, 93.86389923, 92.9352951, 92.03639984, 91.15013885, 90.27630615, 89.43255615, 88.63536072, 87.8986969, 87.23329163, 86.63896942, 86.09989166, 85.60071564, 85.12715912, 84.66781616, 84.21458435, 83.76491547, 83.30849457, 82.86478424, 82.46378326, 82.11483002, 81.82078552, 81.58016968, 81.37005615, 81.18525696, 81.01979065, 80.86772156, 80.72546387, 80.59381104, 80.48122406, 80.40287018, 80.33755493, 80.30010986, 80.28891754, 80.28807831, 80.33933258, 80.44513702, 80.57379913, 80.71469879, 80.86810303, 81.03874207, 81.23072052, 81.44044495, 81.6555481, 81.901474, 82.20778656, 82.67211151, 83.1408844, 83.62628174, 84.0898056, 84.53721619, 84.99518585, 85.49137878, 86.03423309, 86.58794403, 87.16802979, 87.72124481, 88.51965332, 89.35781097, 90.16739655, 90.94639587, 91.75927734, 92.65882111, 93.6033783, 94.64561462, 95.68405914, 96.84765625, 97.98625183, 99.09587097, 100.2806396, 101.5832748, 103.0694122, 104.6378632, 106.2420197, 107.8503952, 109.5214844, 111.3000031, 113.1901169, 115.1414337, 117.1432114, 119.3193054, 121.7141724, 124.2319031, 126.4584961, 128.9876556, 131.6906891, 134.7160034, 137.8343048, 140.7224121, 143.7820892, 147.23909, 150.6812439, 154.0381317, 157.1765747, 160.5133972, 164.2957306, 168.1366272, 171.8247986, 175.4206543, 179.2828827, 182.0374146, 185.0783844, 188.2106171, 190.9611206, 193.3639221, 195.5132294, 197.58255, 199.4234161, 201.3786011, 203.1474609, 205.016037, 206.6236725, 208.1813812, 209.8205719, 211.2774353, 212.8192749, 214.4571686, 215.6442261, 216.4818726, 217.1617279, 217.7372131, 218.2023926, 218.4073486, 218.4278564, 217.6643677, 216.4666748, 215.1212463, 213.8158264, 212.5012817, 210.8331757, 208.8956146, 206.9006958, 204.9239197, 203.0310059, 201.2084045, 199.3484344, 197.3464355, 195.217453, 193.0449677, 190.9578705, 188.9528656, 187.0009918, 185.0068817, 182.9402924, 180.8367767, 178.7057037, 176.5325165, 174.445282, 172.4908905, 170.5744934, 168.5490723, 166.459259, 164.4333649, 162.5092621, 160.4579468, 158.491806, 156.6880035, 155.0045624, 153.295166, 151.4545441, 149.5910492, 147.7821808, 146.4078522, 144.8022614, 143.2662506, 141.8236542, 140.5029602, 139.225174, 137.8959045, 136.4792175, 135.0780334, 133.7389374, 132.7613525, 131.6787109, 130.6356354, 129.64328, 128.7269897, 127.8450623, 126.9439697, 126.0015182, 125.0760727, 124.1718826, 123.4704056, 122.8062363, 122.1408768, 121.501358, 120.9004822, 120.3225555, 119.7514191, 119.2011871, 118.7055511, 118.2950592, 117.9416199, 117.5793762, 117.2029953, 116.8356552, 116.4874039, 116.1693954, 115.9030762, 115.6935577, 115.5213852, 115.3659363, 115.2032318, 115.0445251, 114.9317932, 114.8815384, 114.8605118, 114.8510284, 114.8482819, 114.848465, 114.8521805, 114.8999329, 115.0081787, 115.1483612, 115.2983322, 115.511528, 115.7195816, 115.9448853, 116.2098999, 116.5264893, 116.8126144, 117.1579666, 117.5379944, 117.9048004, 118.3263168, 118.8006821, 119.2988586, 119.8310318, 120.3776703, 121.0383987, 121.6810684, 122.4489899, 123.207077, 124.071022, 124.9082108, 125.74823, 126.6865311, 127.4425888, 127.8552094, 128.1067963, 128.3630676, 128.6606598, 128.9203491, 129.2632141, 129.708252, 130.1131287, 130.5647278, 130.9923553, 131.5979462, 132.2623444, 132.8651428, 133.4651947, 134.1470337, 134.8683624, 135.683609, 136.6136017, 137.5203552, 138.3826599, 139.2931976, 140.2762299, 141.2150574, 142.3930054, 143.7060547, 145.0472565, 146.3404083, 147.6144257, 148.9406586, 150.3545532, 151.8509674, 153.4246826, 155.0567017, 156.7265472, 158.4546509, 160.2428131, 162.1348267, 164.1415863, 166.2302551, 168.4024506, 170.5583649, 172.6457672, 174.9460449, 177.2792664, 179.6472473, 182.1867218, 184.5882721, 187.3068848, 189.8807373, 192.5116577, 195.5551453, 198.5196381, 201.3429413, 203.941452, 206.8439484, 209.5599213, 212.4866943, 215.0750885, 217.929306, 220.6668701, 223.364151, 226.2115479, 228.9524536, 231.5583954, 234.405304, 237.0275879, 239.5091705, 242.0047455, 242.0177155\n    \};\n\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    XYZ_to_AP1.setArray(XYZ_to_AP1_ACES_matrix_data);\n    AP1_to_XYZ = XYZ_to_AP1.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n\n    // LocusLimitMTable = LocusLimitMTable_data;\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      LocusLimitMTable\[i] = LocusLimitMTable_data\[i];\n    \}\n\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n  // Cusp table for limiting gamut\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n    \n    // Cusp table for AP1 gamut\n    \{\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsortedAP1\[i] = AP1_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsortedAP1\[i].z <  gamutCuspTableUnsortedAP1\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTableAP1\[i] = gamutCuspTableUnsortedAP1\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n  \}\n\n\n\n\n\}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    SampleType(extra) sourceExtra = src();\n    float3 extraRGB(sourceExtra.x, sourceExtra.y, sourceExtra.z);\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      if( invert )\n      \{\n        diagnostic =  JMh_to_input_RGB(srcRGB);\n      \}\n      else\n      \{\n        diagnostic =  JMh;\n      \}\n\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    else if (diagnosticMode == 14)\n    \{\n      // output gamut cusp\n      diagnostic = float3(cuspFromTable(srcRGB.z).x, cuspFromTable(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 15)\n    \{\n      // output AP1 cusp\n      diagnostic = float3(cuspFromTableAP1(srcRGB.z).x, cuspFromTableAP1(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 16)\n    \{\n      // output Locus cusp\n      diagnostic = float3(cuspFromTableLocus(srcRGB.z).x, cuspFromTableLocus(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 17)\n    \{\n      // output Locus boundry\n      diagnostic = getLocusBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 18)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0  );\n    \}\n\n\n\n\n    // extra modes to allow for easier breakout of the order of events.\n    // modes starting with 100\n\n    else if (diagnosticMode == 100)\n    \{\n      // output input as luminanceXYZ\n      diagnostic = input_RGB_to_JMh(srcRGB);\n    \}\n\n    else if (diagnosticMode == 101)\n    \{\n      // convert luminanceXYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n\n    else if (diagnosticMode == 102)\n    \{\n      // JMh to tonemappedJMh\n      diagnostic = forwardTonescale(srcRGB, extraRGB);\n    \}\n\n    else if (diagnosticMode == 103)\n    \{\n      // JMh to gamut compressed JMh\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    else if (diagnosticMode == 104)\n    \{\n      // JMh to luminance XYZ\n      diagnostic = JMh_to_XYZ( srcRGB, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n\n    else if (diagnosticMode == 105)\n    \{\n      // luminance XYZ to luminanceRGB\n      diagnostic = JMh_to_output_RGB(srcRGB);\n    \}\n\n    else if (diagnosticMode == 106)\n    \{\n      // luminanceRGB to output RGB\n      diagnostic = luminanceToEncoding3( encodingOut, srcRGB);\n    \}\n\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_simpleCompressMode {{parent.BlinkScript1_DRT_CAM_Kernel_simpleCompressMode}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_Locuscompressmode {{parent.BlinkScript1_DRT_CAM_Kernel_Locuscompressmode}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 102
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -201
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
push $N94906800
Group {
 name J_tonemap
 xpos 329
 ypos 786
}
 Input {
  inputs 0
  name Input1
  xpos 456
  ypos 189
 }
 Dot {
  name Dot2
  xpos 490
  ypos 234
 }
set N94a2b400 [stack 0]
 Dot {
  name Dot1
  xpos 312
  ypos 234
 }
 Dot {
  name Dot3
  xpos 312
  ypos 506
 }
push $N94a2b400
 Group {
  name hellwig_ach
  label "\[value dir]"
  selected true
  xpos 456
  ypos 266
  addUserKnob {20 User}
  addUserKnob {41 useGPUIfAvailable l "Use GPU if available" T ach_helwig.useGPUIfAvailable}
  addUserKnob {41 vectorize l "Vectorize on CPU" -STARTLINE T ach_helwig.vectorize}
  addUserKnob {41 hellwig_ach_L_A l L_A T ach_helwig.hellwig_ach_L_A}
  addUserKnob {41 hellwig_ach_Y_b l Y_b T ach_helwig.hellwig_ach_Y_b}
  addUserKnob {4 surr l surround M {Dark Dim Average}}
  surr Dim
  addUserKnob {4 dir l direction M {Forward Inverse}}
  dir Inverse
  addUserKnob {26 divider l "" +STARTLINE}
  addUserKnob {26 info l "" t "Converts luminance to Hellwig J and vice versa.\n\nY input for the forward transform is taken from the green channel (red and blue are ignored) assuming input is XYZ.\n\nJ input for the inverse transform is taken from the red channel (green and blue are ignored) assuming input is JMh.\n\nThe result is output on all three channels." +STARTLINE T "Luminance to/from Hellwig J"}
 }
  Input {
   inputs 0
   name Input1
   xpos -12
   ypos -71
  }
  BlinkScript {
   kernelSourceFile "\[file dirname \[value root.name]]/hellwig_ach.blink"
   recompileCount 92
   ProgramGroup 1
   KernelDescription "2 \"hellwig_ach\" iterate pixelWise f6c3145803aad678928fe9e4700f573430f8ba0a92d174135e6572553c29afdd 2 \"src\" Read Point \"dst\" Write Point 4 \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"surround\" Int 1 AAAAAA== \"direction\" Int 1 AAAAAA== 4 \"L_A\" 1 1 \"Y_b\" 1 1 \"surround\" 1 1 \"direction\" 1 1 8 \"k\" Float 1 1 AAAAAA== \"k4\" Float 1 1 AAAAAA== \"F_L\" Float 1 1 AAAAAA== \"n\" Float 1 1 AAAAAA== \"z\" Float 1 1 AAAAAA== \"F_L_W\" Float 1 1 AAAAAA== \"A_w\" Float 1 1 AAAAAA== \"S_G\" Float 1 1 AAAAAA=="
   kernelSource "kernel hellwig_ach : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float L_A;\n    float Y_b;\n    int surround;\n    int direction;\n    \n\n  local:\n    float k;\n    float k4;\n    float F_L;\n    float n;\n    float z;\n    float F_L_W;\n    float A_w;\n    float S_G;\n\n  void define() \{\n  \}\n\n  float Y_to_J( float Y, float F_L, float A_w, float S_G, float z )\n  \{\n      float F_L_Y = pow(F_L * fabs(Y) / 100.0f, 0.42f);\n\n      return 100.0f * sign(Y) * pow(((400.0f * F_L_Y) / (27.13f + F_L_Y)) / A_w, S_G * z);\n  \}\n\n  float J_to_Y(float J, float F_L, float A_w, float S_G, float z )\n  \{\n      float A = A_w * sign(J) * pow(fabs(J) / 100.0f, 1.0f / (S_G * z));\n\n      return 100.0f * sign(A) / F_L * pow((27.13f * fabs(A)) / (400.0f - fabs(A)), 1.0f / 0.42f);\n  \}\n\n  void init() \{\n      k = 1.0f / (5.0f * L_A + 1.0f);\n      k4 = k*k*k*k;\n      F_L = 0.2f * k4 * 5.0f * L_A + 0.1f * pow(1.0f - k4, 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f) ;\n      n = Y_b / 100.0f;\n      z = 1.48f + sqrt(n);\n      F_L_W = pow(F_L, 0.42f);\n      A_w = (400.0f * F_L_W) / (27.13f + F_L_W);\n      if(surround==0)\n      \{\n          S_G = 0.525f;\n      \}\n      else if(surround==1)\n      \{\n          S_G = 0.59f;\n      \}\n      else\n      \{\n          S_G = 0.69f;\n      \}\n  \}\n\n  void process() \{\n    SampleType(src) input = src();\n\n    float in;\n    float out;\n\n    if (direction == 0)\n    \{\n        in = input.y;\n        out = Y_to_J(in, F_L, A_w, S_G, z);\n    \}\n    else\n    \{\n        in = input.x;\n        out = J_to_Y(in, F_L, A_w, S_G, z);\n    \}\n\n    dst() = float4(out, out, out, input.w);\n  \}\n\};\n"
   rebuild ""
   hellwig_ach_L_A 100
   hellwig_ach_Y_b 20
   hellwig_ach_surround {{parent.surr}}
   hellwig_ach_direction {{parent.dir}}
   rebuild_finalise ""
   name ach_helwig
   selected true
   xpos -12
   ypos -10
  }
  Output {
   name Output1
   xpos -12
   ypos 69
  }
 end_group
 Multiply {
  value 0.01
  name Div_by_100_1
  xpos 456
  ypos 310
 }
 BlinkScript {
  kernelSourceFile /Users/nick/Desktop/daniele.blink
  recompileCount 27
  ProgramGroup 1
  KernelDescription "2 \"DanieleKernel\" iterate pixelWise f629b20a67898cb5184058c75efab62f2ebcf51f52bf6f23230f8767c3b95849 2 \"src\" Read Point \"dst\" Write Point 10 \"invert\" Bool 1 AA== \"r_hit_min\" Float 1 AAAAAA== \"r_hit_max\" Float 1 AAAAAA== \"g\" Float 1 AAAAAA== \"c\" Float 1 AAAAAA== \"c_d\" Float 1 AAAAAA== \"w_g\" Float 1 AAAAAA== \"t_1\" Float 1 AAAAAA== \"n_r\" Float 1 AAAAAA== \"n\" Float 1 AAAAAA== 10 \"invert\" 1 1 \"r_hit_min\" 1 1 \"r_hit_max\" 1 1 \"g\" 1 1 \"c\" 1 1 \"c_d\" 1 1 \"w_g\" 1 1 \"t_1\" 1 1 \"n_r\" 1 1 \"n\" 1 1 13 \"r_hit\" Float 1 1 AAAAAA== \"m_0\" Float 1 1 AAAAAA== \"m_1\" Float 1 1 AAAAAA== \"u\" Float 1 1 AAAAAA== \"m\" Float 1 1 AAAAAA== \"w_i\" Float 1 1 AAAAAA== \"c_t\" Float 1 1 AAAAAA== \"g_ip\" Float 1 1 AAAAAA== \"g_ipp2\" Float 1 1 AAAAAA== \"w_2\" Float 1 1 AAAAAA== \"s_2\" Float 1 1 AAAAAA== \"u_2\" Float 1 1 AAAAAA== \"m_2\" Float 1 1 AAAAAA=="
  kernelSource "\nkernel DanieleKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    bool invert;\n    float r_hit_min; // scene value hitting the roof at 100 nits\n    float r_hit_max; // scene value hitting the roof at 10000 nits\n    float g; // surround / contrast\n    float c; // scene-referred grey\n    float c_d; // display-referred grey (in nits)\n    float w_g; // grey change between different peak luminance\n    float t_1; // shadow toe, flare/glare compensation - how ever you want to call it\n    float n_r; // Normalised White in nits (what should 1.0 be)\n    float n; // peak white\n\n\n  local:\n    // constants to be pre-calculated\n    float r_hit;\n    float m_0;\n    float m_1;\n    float u;\n    float m;\n    float w_i;\n    float c_t;\n    float g_ip;\n    float g_ipp2;\n    float w_2;\n    float s_2;\n    float u_2;\n    float m_2;\n\n  void define() \{\n  \}\n\n  float daniele_fwd(float Y)\n  \{\n    float f = m_2 * pow(max(0.0f, Y) / (Y + s_2), g);\n    float h = max(0.0f, f * f / (f + t_1));\n\n    return h;\n  \}\n\n  float daniele_rev(float Y)\n  \{\n    Y = max(0.0f, min(n / (u_2 * n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * t_1 + Y)))/2.0f;\n    float f = s_2 / (pow((m_2 / h), (1.0f / g)) - 1.0f);\n\n    return f;\n  \}\n\n  void init() \{\n  // pre-calculate constants\n    r_hit = r_hit_min + (r_hit_max - r_hit_min) * (log(n / n_r) / log(10000.0f / 100.0f));\n    m_0 = n / n_r;\n    m_1 = 0.5f * (m_0 + sqrt(m_0 * (m_0 + 4.0f * t_1)));\n    u = pow((r_hit / m_1) / ((r_hit / m_1) + 1.0f), g);\n    m = m_1 / u;\n    w_i = log(n / 100.0f) / log(2.0f);\n    c_t = c_d * (1.0f + w_i * w_g) / n_r;\n    g_ip = 0.5f * (c_t + sqrt(c_t * (c_t + 4.0f * t_1)));\n    g_ipp2 = -m_1 * pow(g_ip / m, 1.0f / g) / (pow(g_ip / m, 1.0f / g) - 1.0f);\n    w_2 = c / g_ipp2;\n    s_2 = w_2 * m_1;\n    u_2 = pow((r_hit / m_1) / ((r_hit / m_1) + w_2), g);\n    m_2 = m_1 / u_2;\n  \}\n\n  void process() \{\n    // Read the input image\n    SampleType(src) input = src();\n\n    // Isolate the RGB components\n    float3 srcPixel(input.x, input.y, input.z);\n\n    // Apply curve\n    float3 dstPixel;\n    if (invert)\n    \{\n      dstPixel.x = daniele_rev(srcPixel.x);\n      dstPixel.y = daniele_rev(srcPixel.y);\n      dstPixel.z = daniele_rev(srcPixel.z);\n    \}\n    else\n    \{\n      dstPixel.x = daniele_fwd(srcPixel.x);\n      dstPixel.y = daniele_fwd(srcPixel.y);\n      dstPixel.z = daniele_fwd(srcPixel.z);\n    \}\n\n    // Write the result to the output image\n    dst() = float4(dstPixel.x, dstPixel.y, dstPixel.z, input.w);\n  \}\n\};\n"
  rebuild ""
  DanieleKernel_r_hit_min 128
  DanieleKernel_r_hit_max 896
  DanieleKernel_g 1.15
  DanieleKernel_c 0.18
  DanieleKernel_c_d 10.013
  DanieleKernel_w_g 0.14
  DanieleKernel_t_1 0.04
  DanieleKernel_n_r 100
  DanieleKernel_n 100
  rebuild_finalise ""
  name daniele_curve1
  xpos 456
  ypos 355
 }
 Multiply {
  value 100
  name Mult_by_100_2
  xpos 456
  ypos 404
 }
 Group {
  name hellwig_ach1
  label "\[value dir]"
  xpos 456
  ypos 453
  addUserKnob {20 User}
  addUserKnob {41 useGPUIfAvailable l "Use GPU if available" T ach_helwig.useGPUIfAvailable}
  addUserKnob {41 vectorize l "Vectorize on CPU" -STARTLINE T ach_helwig.vectorize}
  addUserKnob {41 hellwig_ach_L_A l L_A T ach_helwig.hellwig_ach_L_A}
  addUserKnob {41 hellwig_ach_Y_b l Y_b T ach_helwig.hellwig_ach_Y_b}
  addUserKnob {4 surr l surround M {Dark Dim Average}}
  surr Dim
  addUserKnob {4 dir l direction M {Forward Inverse}}
  addUserKnob {26 divider l "" +STARTLINE}
  addUserKnob {26 info l "" t "Converts luminance to Hellwig J and vice versa.\n\nY input for the forward transform is taken from the green channel (red and blue are ignored) assuming input is XYZ.\n\nJ input for the inverse transform is taken from the red channel (green and blue are ignored) assuming input is JMh.\n\nThe result is output on all three channels." +STARTLINE T "Luminance to/from Hellwig J"}
 }
  Input {
   inputs 0
   name Input1
   xpos -12
   ypos -71
  }
  BlinkScript {
   kernelSourceFile "\[file dirname \[value root.name]]/hellwig_ach.blink"
   recompileCount 90
   ProgramGroup 1
   KernelDescription "2 \"hellwig_ach\" iterate pixelWise a4e1de2e8eacf06b93bba42939cdf796e01a083a99f92b327d1a558a1f785cfc 2 \"src\" Read Point \"dst\" Write Point 4 \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"surround\" Int 1 AAAAAA== \"direction\" Int 1 AAAAAA== 4 \"L_A\" 1 1 \"Y_b\" 1 1 \"surround\" 1 1 \"direction\" 1 1 8 \"k\" Float 1 1 AAAAAA== \"k4\" Float 1 1 AAAAAA== \"F_L\" Float 1 1 AAAAAA== \"n\" Float 1 1 AAAAAA== \"z\" Float 1 1 AAAAAA== \"F_L_W\" Float 1 1 AAAAAA== \"A_w\" Float 1 1 AAAAAA== \"S_G\" Float 1 1 AAAAAA=="
   kernelSource "kernel hellwig_ach : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    float L_A;\n    float Y_b;\n    int surround;\n    int direction;\n    \n\n  local:\n    float k;\n    float k4;\n    float F_L;\n    float n;\n    float z;\n    float F_L_W;\n    float A_w;\n    float S_G;\n\n  void define() \{\n  \}\n\n  float Y_to_J( float Y, float F_L, float A_w, float S_G, float z )\n  \{\n      float F_L_Y = pow(F_L * fabs(Y) / 100.0f, 0.42f);\n\n      return 100.0f * sign(Y) * pow(((400.0f * F_L_Y) / (27.13f + F_L_Y)) / A_w, S_G * z);\n  \}\n\n  float J_to_Y(float J, float F_L, float A_w, float S_G, float z )\n  \{\n      float A = A_w * sign(J) * pow(fabs(J) / 100.0f, 1.0f / (S_G * z));\n\n      return 100.0f * sign(A) / F_L * pow((27.13f * fabs(A)) / (400.0f - fabs(A)), 1.0f / 0.42f);\n  \}\n\n  void init() \{\n      k = 1.0f / (5.0f * L_A + 1.0f);\n      k4 = k*k*k*k;\n      F_L = 0.2f * k4 * 5.0f * L_A + 0.1f * pow(1.0f - k4, 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f) ;\n      n = Y_b / 100.0f;\n      z = 1.48f + sqrt(n);\n      F_L_W = pow(F_L, 0.42f);\n      A_w = (400.0f * F_L_W) / (27.13f + F_L_W);\n      if(surround==0)\n      \{\n          S_G = 0.525f;\n      \}\n      else if(surround==1)\n      \{\n          S_G = 0.59f;\n      \}\n      else\n      \{\n          S_G = 0.69f;\n      \}\n  \}\n\n  void process() \{\n    SampleType(src) input = src();\n\n    float in;\n    float out;\n\n    if (direction == 0)\n    \{\n        in = input.y;\n        out = Y_to_J(in, F_L, A_w, S_G, z);\n    \}\n    else\n    \{\n        in = input.x;\n        out = J_to_Y(in, F_L, A_w, S_G, z);\n    \}\n\n    dst() = float4(out, out, out, input.w);\n  \}\n\};\n"
   rebuild ""
   hellwig_ach_L_A 100
   hellwig_ach_Y_b 20
   hellwig_ach_surround {{parent.surr}}
   hellwig_ach_direction {{parent.dir}}
   rebuild_finalise ""
   name ach_helwig
   xpos -12
   ypos -10
  }
  Output {
   name Output1
   xpos -12
   ypos 69
  }
 end_group
 Shuffle2 {
  inputs 2
  fromInput1 {{0} B A}
  fromInput2 {{1} B A}
  in2 rgba
  mappings "4 rgba.red 0 0 rgba.red 0 0 rgba.alpha 0 3 rgba.alpha 0 3 rgba.green 1 1 rgba.green 0 1 rgba.blue 1 2 rgba.blue 0 2"
  name Shuffle1
  xpos 456
  ypos 503
 }
 Output {
  name Output1
  xpos 456
  ypos 541
 }
end_group
set N12c82e00 [stack 0]
push $N94906800
Merge2 {
 inputs 2
 operation divide
 name Merge1
 xpos 329
 ypos 836
}
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 white -1 -1 rgba.red 0 0 rgba.alpha 0 3 rgba.alpha 0 3 rgba.red 0 0 rgba.green 0 1 white -1 -1 rgba.blue 0 2"
 name Shuffle1
 xpos 329
 ypos 891
}
Dot {
 name Dot4
 xpos 363
 ypos 936
}
push $N12c82e00
Dot {
 name Dot1
 xpos 473
 ypos 789
}
Merge2 {
 inputs 2
 operation multiply
 name Merge2
 xpos 439
 ypos 933
 disable {{!DRT_CAM3.applyChromaCompression}}
}
Dot {
 name Dot2
 xpos 473
 ypos 1010
}
Switch {
 inputs 2
 which -1
 name Switch1
 xpos 62
 ypos 1007
}
Dot {
 name Dot3
 xpos 96
 ypos 1208
}
Group {
 name DRT_CAM4
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos -488
 ypos 1175
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {6 BlinkScript1_DRT_CAM_Kernel_simpleCompressMode l simpleCompressMode -STARTLINE}
 BlinkScript1_DRT_CAM_Kernel_simpleCompressMode true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit sRGB/Rec.709-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 1000
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.7 1.2 1.7 1}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_AP1compressmode l AP1compressmode T BlinkScript1.DRT_CAM_Kernel_AP1compressmode}
 addUserKnob {6 BlinkScript1_DRT_CAM_Kernel_Locuscompressmode l Locuscompressmode +STARTLINE}
 BlinkScript1_DRT_CAM_Kernel_Locuscompressmode true
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.2 1.4 {compressionFuncParamsR.g} 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {{compressionFuncParamsR.r} 1.21 {compressionFuncParamsY.g} 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {{compressionFuncParamsR.r} 1.3 {compressionFuncParamsG.g} 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {{compressionFuncParamsR.r} 1.9 {compressionFuncParamsC.g} 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {{compressionFuncParamsR.r} 1.2 {compressionFuncParamsB.g} 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {{compressionFuncParamsR.r} 1.23 {compressionFuncParamsM.g} 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out sRGB
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out P3-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name extra
  xpos -1244
  ypos -259
  number 1
 }
 Reformat {
  inputs 0
  name Reformat1
  xpos -1120
  ypos -264
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input1]"}}
  name Switch1
  xpos -1120
  ypos -195
 }
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  inputs 2
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v038.blink
  recompileCount 2561
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b01ab31261204a9edd5ee1cd13bdd2e603d7a9a00100add44c8b8f3d5ce677ab 3 \"src\" Read Point \"extra\" Read Point \"dst\" Write Point 74 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"simpleCompressMode\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"AP1compressmode\" Bool 1 AA== \"Locuscompressmode\" Bool 1 AA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 74 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"simpleCompressMode\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"AP1compressmode\" 1 1 \"Locuscompressmode\" 1 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 52 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTableUnsortedAP1\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTableAP1\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LocusLimitMTable\" Float 1 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> extra; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n    bool simpleCompressMode;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n    bool AP1compressmode;\n    bool Locuscompressmode;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    float3x3 AP1_to_XYZ;\n    float3x3 XYZ_to_AP1;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 gamutCuspTableUnsortedAP1\[360];\n    float3 gamutCuspTableAP1\[360];\n    float3 cgamutCuspTable\[360];\n    float LocusLimitMTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n\n    // switch to treat incoming data as luminanceXYZ when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      luminanceXYZ = JMh;\n    \}\n\n\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    // return luminanceRGB when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      return luminanceRGB;\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n  // convert linear RGB values with the AP1 primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 AP1_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(AP1_to_XYZ, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n    float2 cuspFromTableAP1(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTableAP1\[0].z )\n    \{\n      lo = gamutCuspTableAP1\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTableAP1\[0];\n    \}\n    else if( h >= gamutCuspTableAP1\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTableAP1\[gamutCuspTableSize-1];\n      hi = gamutCuspTableAP1\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTableAP1\[i].z )\n        \{\n          lo = gamutCuspTableAP1\[i-1];\n          hi = gamutCuspTableAP1\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n\n  float2 cuspFromTableLocus(float h)\n  \{\n\n    // float lo;\n    // float hi;\n\n    // if( h <= LocusLimitMTable\[0] )\n    // \{\n    //   lo = LocusLimitMTable\[gamutCuspTableSize-1];\n    //   lo = lo-360.0f;\n    //   hi = LocusLimitMTable\[0];\n    // \}\n    // else if( h >= LocusLimitMTable\[gamutCuspTableSize-1] )\n    // \{\n    //   lo = LocusLimitMTable\[gamutCuspTableSize-1];\n    //   hi = LocusLimitMTable\[0];\n    //   hi = hi+360.f;\n    // \}\n    // else\n    // \{\n    //   for(int i = 1; i < gamutCuspTableSize; ++i)\n    //   \{\n    //     if( h <= LocusLimitMTable\[i] )\n    //     \{\n    //       lo = LocusLimitMTable\[i-1];\n    //       hi = LocusLimitMTable\[i];\n    //       break;\n    //     \}\n    //   \}\n    // \}\n\n    // float t = (h - lo) / (hi - lo);\n\n    float cuspJ = 69;\n    // float cuspM = lerp(lo, hi, t);\n    float cuspM = LocusLimitMTable\[int(h)];\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (simpleCompressMode)\n    \{\n      if (!invert)\n      \{\n        M =  JMh.y * ( JMh.x / origJ);\n      \}\n      else\n      \{\n        M =  JMh.y * ( JMh.x / origJ);\n      \}\n      return M;\n    \}\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n      M = min(M,JMh.y);\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6 || diagnosticMode == 100)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n  float3 getLocusBoundry(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float2 cuspLocus = cuspFromTableLocus(h);\n    float cuspTarget100 = cuspLocus.y;\n    // 0.86 has been eyeballed to match the locus in Nuke\n    float cuspTarget = cuspTarget100 * pow((Jmh.x/100.0f),0.86f);\n    float difference =  cuspLocus.y / cuspTarget;\n    return float3(Jmh.x,cuspTarget,Jmh.z);\n  \}\n\n\n  float4 getCompressionFuncParams(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float angleR = 20.0f;\n    float angleY = 102.0f;\n    float angleG = 146.0f;\n    float angleC = 193.0f;\n    float angleB = 259.0f;\n    float angleM = 342.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if(AP1compressmode)\n    \{\n        float2 cuspAP1 = cuspFromTableAP1(h);\n        float2 cuspTarget = cuspFromTable(h);\n        float difference =  cuspAP1.y / cuspTarget.y;\n        return float4(0.2,difference,difference,1.0);\n    \}\n    if(Locuscompressmode)\n    \{\n        // float2 cuspLocus = cuspFromTableLocus(h);\n        float cuspTarget = cuspFromTable(h).y;\n        float locusMax = getLocusBoundry(Jmh).y;\n        // float cuspTarget = cuspTarget100 * (Jmh.x/100.0f);\n        float difference =  locusMax / Jmh.y;\n        // float difference = Jmh.y;\n        return float4(compressionFuncParams.x,difference,difference,compressionFuncParams.w);\n        // return float4(compressionFuncParams.x,locusMax,Jmh.y,compressionFuncParams.w);\n    \}\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    // float2 project_to = float2(project_from.x, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n    // float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_from, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMh.x,JMboundary.y,JMh.z));\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      // JMcompressed = project_to + v * (JMboundary - project_to);\n      JMcompressed = float2(JMh.x,v*JMboundary.y);\n    \}\n\n    // Diagnostic outputs\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 18)\n    \{\n      // return float3(interpolatedCompressionFuncParams.y, interpolatedCompressionFuncParams.z, JMh.z);\n      return float3(JMh.x, JMboundary.y, JMh.z);\n    \}\n    // actual output\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // M Max data generated via an external Nukescript at a J value of 100\n    float LocusLimitMTable_data\[]=\n    \{\n      244.8230133, 245.4952393, 246.4431458, 247.1381531, 247.2368927, 246.8459778, 245.7083588, 244.2591095, 242.5463409, 240.4208374, 238.0180511, 235.4039917, 233.010849, 230.4004669, 227.8723602, 225.2279968, 222.7197876, 214.8562622, 206.1778564, 198.0664215, 190.9799347, 184.005127, 177.7472992, 172.2332611, 166.6447754, 161.64534, 156.9872284, 152.6203003, 148.3236084, 144.2987976, 140.8540192, 137.4315033, 134.3281555, 131.2306366, 128.3477631, 125.8098145, 123.1305542, 120.5120163, 118.3302231, 116.127861, 114.0526428, 112.1633072, 110.2943344, 108.4250336, 106.711853, 105.188797, 103.6860809, 102.2319641, 100.8348923, 99.51873779, 98.26163483, 97.04810333, 95.90451813, 94.84623718, 93.86389923, 92.9352951, 92.03639984, 91.15013885, 90.27630615, 89.43255615, 88.63536072, 87.8986969, 87.23329163, 86.63896942, 86.09989166, 85.60071564, 85.12715912, 84.66781616, 84.21458435, 83.76491547, 83.30849457, 82.86478424, 82.46378326, 82.11483002, 81.82078552, 81.58016968, 81.37005615, 81.18525696, 81.01979065, 80.86772156, 80.72546387, 80.59381104, 80.48122406, 80.40287018, 80.33755493, 80.30010986, 80.28891754, 80.28807831, 80.33933258, 80.44513702, 80.57379913, 80.71469879, 80.86810303, 81.03874207, 81.23072052, 81.44044495, 81.6555481, 81.901474, 82.20778656, 82.67211151, 83.1408844, 83.62628174, 84.0898056, 84.53721619, 84.99518585, 85.49137878, 86.03423309, 86.58794403, 87.16802979, 87.72124481, 88.51965332, 89.35781097, 90.16739655, 90.94639587, 91.75927734, 92.65882111, 93.6033783, 94.64561462, 95.68405914, 96.84765625, 97.98625183, 99.09587097, 100.2806396, 101.5832748, 103.0694122, 104.6378632, 106.2420197, 107.8503952, 109.5214844, 111.3000031, 113.1901169, 115.1414337, 117.1432114, 119.3193054, 121.7141724, 124.2319031, 126.4584961, 128.9876556, 131.6906891, 134.7160034, 137.8343048, 140.7224121, 143.7820892, 147.23909, 150.6812439, 154.0381317, 157.1765747, 160.5133972, 164.2957306, 168.1366272, 171.8247986, 175.4206543, 179.2828827, 182.0374146, 185.0783844, 188.2106171, 190.9611206, 193.3639221, 195.5132294, 197.58255, 199.4234161, 201.3786011, 203.1474609, 205.016037, 206.6236725, 208.1813812, 209.8205719, 211.2774353, 212.8192749, 214.4571686, 215.6442261, 216.4818726, 217.1617279, 217.7372131, 218.2023926, 218.4073486, 218.4278564, 217.6643677, 216.4666748, 215.1212463, 213.8158264, 212.5012817, 210.8331757, 208.8956146, 206.9006958, 204.9239197, 203.0310059, 201.2084045, 199.3484344, 197.3464355, 195.217453, 193.0449677, 190.9578705, 188.9528656, 187.0009918, 185.0068817, 182.9402924, 180.8367767, 178.7057037, 176.5325165, 174.445282, 172.4908905, 170.5744934, 168.5490723, 166.459259, 164.4333649, 162.5092621, 160.4579468, 158.491806, 156.6880035, 155.0045624, 153.295166, 151.4545441, 149.5910492, 147.7821808, 146.4078522, 144.8022614, 143.2662506, 141.8236542, 140.5029602, 139.225174, 137.8959045, 136.4792175, 135.0780334, 133.7389374, 132.7613525, 131.6787109, 130.6356354, 129.64328, 128.7269897, 127.8450623, 126.9439697, 126.0015182, 125.0760727, 124.1718826, 123.4704056, 122.8062363, 122.1408768, 121.501358, 120.9004822, 120.3225555, 119.7514191, 119.2011871, 118.7055511, 118.2950592, 117.9416199, 117.5793762, 117.2029953, 116.8356552, 116.4874039, 116.1693954, 115.9030762, 115.6935577, 115.5213852, 115.3659363, 115.2032318, 115.0445251, 114.9317932, 114.8815384, 114.8605118, 114.8510284, 114.8482819, 114.848465, 114.8521805, 114.8999329, 115.0081787, 115.1483612, 115.2983322, 115.511528, 115.7195816, 115.9448853, 116.2098999, 116.5264893, 116.8126144, 117.1579666, 117.5379944, 117.9048004, 118.3263168, 118.8006821, 119.2988586, 119.8310318, 120.3776703, 121.0383987, 121.6810684, 122.4489899, 123.207077, 124.071022, 124.9082108, 125.74823, 126.6865311, 127.4425888, 127.8552094, 128.1067963, 128.3630676, 128.6606598, 128.9203491, 129.2632141, 129.708252, 130.1131287, 130.5647278, 130.9923553, 131.5979462, 132.2623444, 132.8651428, 133.4651947, 134.1470337, 134.8683624, 135.683609, 136.6136017, 137.5203552, 138.3826599, 139.2931976, 140.2762299, 141.2150574, 142.3930054, 143.7060547, 145.0472565, 146.3404083, 147.6144257, 148.9406586, 150.3545532, 151.8509674, 153.4246826, 155.0567017, 156.7265472, 158.4546509, 160.2428131, 162.1348267, 164.1415863, 166.2302551, 168.4024506, 170.5583649, 172.6457672, 174.9460449, 177.2792664, 179.6472473, 182.1867218, 184.5882721, 187.3068848, 189.8807373, 192.5116577, 195.5551453, 198.5196381, 201.3429413, 203.941452, 206.8439484, 209.5599213, 212.4866943, 215.0750885, 217.929306, 220.6668701, 223.364151, 226.2115479, 228.9524536, 231.5583954, 234.405304, 237.0275879, 239.5091705, 242.0047455, 242.0177155\n    \};\n\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    XYZ_to_AP1.setArray(XYZ_to_AP1_ACES_matrix_data);\n    AP1_to_XYZ = XYZ_to_AP1.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n\n    // LocusLimitMTable = LocusLimitMTable_data;\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      LocusLimitMTable\[i] = LocusLimitMTable_data\[i];\n    \}\n\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n  // Cusp table for limiting gamut\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n    \n    // Cusp table for AP1 gamut\n    \{\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsortedAP1\[i] = AP1_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsortedAP1\[i].z <  gamutCuspTableUnsortedAP1\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTableAP1\[i] = gamutCuspTableUnsortedAP1\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n  \}\n\n\n\n\n\}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    SampleType(extra) sourceExtra = src();\n    float3 extraRGB(sourceExtra.x, sourceExtra.y, sourceExtra.z);\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      if( invert )\n      \{\n        diagnostic =  JMh_to_input_RGB(srcRGB);\n      \}\n      else\n      \{\n        diagnostic =  JMh;\n      \}\n\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    else if (diagnosticMode == 14)\n    \{\n      // output gamut cusp\n      diagnostic = float3(cuspFromTable(srcRGB.z).x, cuspFromTable(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 15)\n    \{\n      // output AP1 cusp\n      diagnostic = float3(cuspFromTableAP1(srcRGB.z).x, cuspFromTableAP1(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 16)\n    \{\n      // output Locus cusp\n      diagnostic = float3(cuspFromTableLocus(srcRGB.z).x, cuspFromTableLocus(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 17)\n    \{\n      // output Locus boundry\n      diagnostic = getLocusBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 18)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0  );\n    \}\n\n\n\n\n    // extra modes to allow for easier breakout of the order of events.\n    // modes starting with 100\n\n    else if (diagnosticMode == 100)\n    \{\n      // output input as luminanceXYZ\n      diagnostic = input_RGB_to_JMh(srcRGB);\n    \}\n\n    else if (diagnosticMode == 101)\n    \{\n      // convert luminanceXYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n\n    else if (diagnosticMode == 102)\n    \{\n      // JMh to tonemappedJMh\n      diagnostic = forwardTonescale(srcRGB, extraRGB);\n    \}\n\n    else if (diagnosticMode == 103)\n    \{\n      // JMh to gamut compressed JMh\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    else if (diagnosticMode == 104)\n    \{\n      // JMh to luminance XYZ\n      diagnostic = JMh_to_XYZ( srcRGB, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n\n    else if (diagnosticMode == 105)\n    \{\n      // luminance XYZ to luminanceRGB\n      diagnostic = JMh_to_output_RGB(srcRGB);\n    \}\n\n    else if (diagnosticMode == 106)\n    \{\n      // luminanceRGB to output RGB\n      diagnostic = luminanceToEncoding3( encodingOut, srcRGB);\n    \}\n\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_simpleCompressMode {{parent.BlinkScript1_DRT_CAM_Kernel_simpleCompressMode}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_Locuscompressmode {{parent.BlinkScript1_DRT_CAM_Kernel_Locuscompressmode}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 103
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -201
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Group {
 name DRT_CAM5
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos -488
 ypos 1382
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {6 BlinkScript1_DRT_CAM_Kernel_simpleCompressMode l simpleCompressMode -STARTLINE}
 BlinkScript1_DRT_CAM_Kernel_simpleCompressMode true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit P3-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 1000
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.7 1.2 1.7 1}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_AP1compressmode l AP1compressmode T BlinkScript1.DRT_CAM_Kernel_AP1compressmode}
 addUserKnob {6 BlinkScript1_DRT_CAM_Kernel_Locuscompressmode l Locuscompressmode +STARTLINE}
 BlinkScript1_DRT_CAM_Kernel_Locuscompressmode true
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.2 1.4 {compressionFuncParamsR.g} 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {{compressionFuncParamsR.r} 1.21 {compressionFuncParamsY.g} 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {{compressionFuncParamsR.r} 1.3 {compressionFuncParamsG.g} 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {{compressionFuncParamsR.r} 1.9 {compressionFuncParamsC.g} 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {{compressionFuncParamsR.r} 1.2 {compressionFuncParamsB.g} 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {{compressionFuncParamsR.r} 1.23 {compressionFuncParamsM.g} 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out sRGB
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out P3-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name extra
  xpos -1244
  ypos -259
  number 1
 }
 Reformat {
  inputs 0
  name Reformat1
  xpos -1120
  ypos -264
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input1]"}}
  name Switch1
  xpos -1120
  ypos -195
 }
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  inputs 2
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v038.blink
  recompileCount 2561
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b01ab31261204a9edd5ee1cd13bdd2e603d7a9a00100add44c8b8f3d5ce677ab 3 \"src\" Read Point \"extra\" Read Point \"dst\" Write Point 74 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"simpleCompressMode\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"AP1compressmode\" Bool 1 AA== \"Locuscompressmode\" Bool 1 AA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 74 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"simpleCompressMode\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"AP1compressmode\" 1 1 \"Locuscompressmode\" 1 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 52 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTableUnsortedAP1\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTableAP1\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LocusLimitMTable\" Float 1 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> extra; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n    bool simpleCompressMode;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n    bool AP1compressmode;\n    bool Locuscompressmode;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    float3x3 AP1_to_XYZ;\n    float3x3 XYZ_to_AP1;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 gamutCuspTableUnsortedAP1\[360];\n    float3 gamutCuspTableAP1\[360];\n    float3 cgamutCuspTable\[360];\n    float LocusLimitMTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n\n    // switch to treat incoming data as luminanceXYZ when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      luminanceXYZ = JMh;\n    \}\n\n\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    // return luminanceRGB when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      return luminanceRGB;\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n  // convert linear RGB values with the AP1 primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 AP1_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(AP1_to_XYZ, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n    float2 cuspFromTableAP1(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTableAP1\[0].z )\n    \{\n      lo = gamutCuspTableAP1\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTableAP1\[0];\n    \}\n    else if( h >= gamutCuspTableAP1\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTableAP1\[gamutCuspTableSize-1];\n      hi = gamutCuspTableAP1\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTableAP1\[i].z )\n        \{\n          lo = gamutCuspTableAP1\[i-1];\n          hi = gamutCuspTableAP1\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n\n  float2 cuspFromTableLocus(float h)\n  \{\n\n    // float lo;\n    // float hi;\n\n    // if( h <= LocusLimitMTable\[0] )\n    // \{\n    //   lo = LocusLimitMTable\[gamutCuspTableSize-1];\n    //   lo = lo-360.0f;\n    //   hi = LocusLimitMTable\[0];\n    // \}\n    // else if( h >= LocusLimitMTable\[gamutCuspTableSize-1] )\n    // \{\n    //   lo = LocusLimitMTable\[gamutCuspTableSize-1];\n    //   hi = LocusLimitMTable\[0];\n    //   hi = hi+360.f;\n    // \}\n    // else\n    // \{\n    //   for(int i = 1; i < gamutCuspTableSize; ++i)\n    //   \{\n    //     if( h <= LocusLimitMTable\[i] )\n    //     \{\n    //       lo = LocusLimitMTable\[i-1];\n    //       hi = LocusLimitMTable\[i];\n    //       break;\n    //     \}\n    //   \}\n    // \}\n\n    // float t = (h - lo) / (hi - lo);\n\n    float cuspJ = 69;\n    // float cuspM = lerp(lo, hi, t);\n    float cuspM = LocusLimitMTable\[int(h)];\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (simpleCompressMode)\n    \{\n      if (!invert)\n      \{\n        M =  JMh.y * ( JMh.x / origJ);\n      \}\n      else\n      \{\n        M =  JMh.y * ( JMh.x / origJ);\n      \}\n      return M;\n    \}\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n      M = min(M,JMh.y);\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6 || diagnosticMode == 100)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n  float3 getLocusBoundry(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float2 cuspLocus = cuspFromTableLocus(h);\n    float cuspTarget100 = cuspLocus.y;\n    // 0.86 has been eyeballed to match the locus in Nuke\n    float cuspTarget = cuspTarget100 * pow((Jmh.x/100.0f),0.86f);\n    float difference =  cuspLocus.y / cuspTarget;\n    return float3(Jmh.x,cuspTarget,Jmh.z);\n  \}\n\n\n  float4 getCompressionFuncParams(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float angleR = 20.0f;\n    float angleY = 102.0f;\n    float angleG = 146.0f;\n    float angleC = 193.0f;\n    float angleB = 259.0f;\n    float angleM = 342.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if(AP1compressmode)\n    \{\n        float2 cuspAP1 = cuspFromTableAP1(h);\n        float2 cuspTarget = cuspFromTable(h);\n        float difference =  cuspAP1.y / cuspTarget.y;\n        return float4(0.2,difference,difference,1.0);\n    \}\n    if(Locuscompressmode)\n    \{\n        // float2 cuspLocus = cuspFromTableLocus(h);\n        float cuspTarget = cuspFromTable(h).y;\n        float locusMax = getLocusBoundry(Jmh).y;\n        // float cuspTarget = cuspTarget100 * (Jmh.x/100.0f);\n        float difference =  locusMax / Jmh.y;\n        // float difference = Jmh.y;\n        return float4(compressionFuncParams.x,difference,difference,compressionFuncParams.w);\n        // return float4(compressionFuncParams.x,locusMax,Jmh.y,compressionFuncParams.w);\n    \}\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    // float2 project_to = float2(project_from.x, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n    // float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_from, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMh.x,JMboundary.y,JMh.z));\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      // JMcompressed = project_to + v * (JMboundary - project_to);\n      JMcompressed = float2(JMh.x,v*JMboundary.y);\n    \}\n\n    // Diagnostic outputs\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 18)\n    \{\n      // return float3(interpolatedCompressionFuncParams.y, interpolatedCompressionFuncParams.z, JMh.z);\n      return float3(JMh.x, JMboundary.y, JMh.z);\n    \}\n    // actual output\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // M Max data generated via an external Nukescript at a J value of 100\n    float LocusLimitMTable_data\[]=\n    \{\n      244.8230133, 245.4952393, 246.4431458, 247.1381531, 247.2368927, 246.8459778, 245.7083588, 244.2591095, 242.5463409, 240.4208374, 238.0180511, 235.4039917, 233.010849, 230.4004669, 227.8723602, 225.2279968, 222.7197876, 214.8562622, 206.1778564, 198.0664215, 190.9799347, 184.005127, 177.7472992, 172.2332611, 166.6447754, 161.64534, 156.9872284, 152.6203003, 148.3236084, 144.2987976, 140.8540192, 137.4315033, 134.3281555, 131.2306366, 128.3477631, 125.8098145, 123.1305542, 120.5120163, 118.3302231, 116.127861, 114.0526428, 112.1633072, 110.2943344, 108.4250336, 106.711853, 105.188797, 103.6860809, 102.2319641, 100.8348923, 99.51873779, 98.26163483, 97.04810333, 95.90451813, 94.84623718, 93.86389923, 92.9352951, 92.03639984, 91.15013885, 90.27630615, 89.43255615, 88.63536072, 87.8986969, 87.23329163, 86.63896942, 86.09989166, 85.60071564, 85.12715912, 84.66781616, 84.21458435, 83.76491547, 83.30849457, 82.86478424, 82.46378326, 82.11483002, 81.82078552, 81.58016968, 81.37005615, 81.18525696, 81.01979065, 80.86772156, 80.72546387, 80.59381104, 80.48122406, 80.40287018, 80.33755493, 80.30010986, 80.28891754, 80.28807831, 80.33933258, 80.44513702, 80.57379913, 80.71469879, 80.86810303, 81.03874207, 81.23072052, 81.44044495, 81.6555481, 81.901474, 82.20778656, 82.67211151, 83.1408844, 83.62628174, 84.0898056, 84.53721619, 84.99518585, 85.49137878, 86.03423309, 86.58794403, 87.16802979, 87.72124481, 88.51965332, 89.35781097, 90.16739655, 90.94639587, 91.75927734, 92.65882111, 93.6033783, 94.64561462, 95.68405914, 96.84765625, 97.98625183, 99.09587097, 100.2806396, 101.5832748, 103.0694122, 104.6378632, 106.2420197, 107.8503952, 109.5214844, 111.3000031, 113.1901169, 115.1414337, 117.1432114, 119.3193054, 121.7141724, 124.2319031, 126.4584961, 128.9876556, 131.6906891, 134.7160034, 137.8343048, 140.7224121, 143.7820892, 147.23909, 150.6812439, 154.0381317, 157.1765747, 160.5133972, 164.2957306, 168.1366272, 171.8247986, 175.4206543, 179.2828827, 182.0374146, 185.0783844, 188.2106171, 190.9611206, 193.3639221, 195.5132294, 197.58255, 199.4234161, 201.3786011, 203.1474609, 205.016037, 206.6236725, 208.1813812, 209.8205719, 211.2774353, 212.8192749, 214.4571686, 215.6442261, 216.4818726, 217.1617279, 217.7372131, 218.2023926, 218.4073486, 218.4278564, 217.6643677, 216.4666748, 215.1212463, 213.8158264, 212.5012817, 210.8331757, 208.8956146, 206.9006958, 204.9239197, 203.0310059, 201.2084045, 199.3484344, 197.3464355, 195.217453, 193.0449677, 190.9578705, 188.9528656, 187.0009918, 185.0068817, 182.9402924, 180.8367767, 178.7057037, 176.5325165, 174.445282, 172.4908905, 170.5744934, 168.5490723, 166.459259, 164.4333649, 162.5092621, 160.4579468, 158.491806, 156.6880035, 155.0045624, 153.295166, 151.4545441, 149.5910492, 147.7821808, 146.4078522, 144.8022614, 143.2662506, 141.8236542, 140.5029602, 139.225174, 137.8959045, 136.4792175, 135.0780334, 133.7389374, 132.7613525, 131.6787109, 130.6356354, 129.64328, 128.7269897, 127.8450623, 126.9439697, 126.0015182, 125.0760727, 124.1718826, 123.4704056, 122.8062363, 122.1408768, 121.501358, 120.9004822, 120.3225555, 119.7514191, 119.2011871, 118.7055511, 118.2950592, 117.9416199, 117.5793762, 117.2029953, 116.8356552, 116.4874039, 116.1693954, 115.9030762, 115.6935577, 115.5213852, 115.3659363, 115.2032318, 115.0445251, 114.9317932, 114.8815384, 114.8605118, 114.8510284, 114.8482819, 114.848465, 114.8521805, 114.8999329, 115.0081787, 115.1483612, 115.2983322, 115.511528, 115.7195816, 115.9448853, 116.2098999, 116.5264893, 116.8126144, 117.1579666, 117.5379944, 117.9048004, 118.3263168, 118.8006821, 119.2988586, 119.8310318, 120.3776703, 121.0383987, 121.6810684, 122.4489899, 123.207077, 124.071022, 124.9082108, 125.74823, 126.6865311, 127.4425888, 127.8552094, 128.1067963, 128.3630676, 128.6606598, 128.9203491, 129.2632141, 129.708252, 130.1131287, 130.5647278, 130.9923553, 131.5979462, 132.2623444, 132.8651428, 133.4651947, 134.1470337, 134.8683624, 135.683609, 136.6136017, 137.5203552, 138.3826599, 139.2931976, 140.2762299, 141.2150574, 142.3930054, 143.7060547, 145.0472565, 146.3404083, 147.6144257, 148.9406586, 150.3545532, 151.8509674, 153.4246826, 155.0567017, 156.7265472, 158.4546509, 160.2428131, 162.1348267, 164.1415863, 166.2302551, 168.4024506, 170.5583649, 172.6457672, 174.9460449, 177.2792664, 179.6472473, 182.1867218, 184.5882721, 187.3068848, 189.8807373, 192.5116577, 195.5551453, 198.5196381, 201.3429413, 203.941452, 206.8439484, 209.5599213, 212.4866943, 215.0750885, 217.929306, 220.6668701, 223.364151, 226.2115479, 228.9524536, 231.5583954, 234.405304, 237.0275879, 239.5091705, 242.0047455, 242.0177155\n    \};\n\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    XYZ_to_AP1.setArray(XYZ_to_AP1_ACES_matrix_data);\n    AP1_to_XYZ = XYZ_to_AP1.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n\n    // LocusLimitMTable = LocusLimitMTable_data;\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      LocusLimitMTable\[i] = LocusLimitMTable_data\[i];\n    \}\n\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n  // Cusp table for limiting gamut\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n    \n    // Cusp table for AP1 gamut\n    \{\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsortedAP1\[i] = AP1_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsortedAP1\[i].z <  gamutCuspTableUnsortedAP1\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTableAP1\[i] = gamutCuspTableUnsortedAP1\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n  \}\n\n\n\n\n\}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    SampleType(extra) sourceExtra = src();\n    float3 extraRGB(sourceExtra.x, sourceExtra.y, sourceExtra.z);\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      if( invert )\n      \{\n        diagnostic =  JMh_to_input_RGB(srcRGB);\n      \}\n      else\n      \{\n        diagnostic =  JMh;\n      \}\n\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    else if (diagnosticMode == 14)\n    \{\n      // output gamut cusp\n      diagnostic = float3(cuspFromTable(srcRGB.z).x, cuspFromTable(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 15)\n    \{\n      // output AP1 cusp\n      diagnostic = float3(cuspFromTableAP1(srcRGB.z).x, cuspFromTableAP1(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 16)\n    \{\n      // output Locus cusp\n      diagnostic = float3(cuspFromTableLocus(srcRGB.z).x, cuspFromTableLocus(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 17)\n    \{\n      // output Locus boundry\n      diagnostic = getLocusBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 18)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0  );\n    \}\n\n\n\n\n    // extra modes to allow for easier breakout of the order of events.\n    // modes starting with 100\n\n    else if (diagnosticMode == 100)\n    \{\n      // output input as luminanceXYZ\n      diagnostic = input_RGB_to_JMh(srcRGB);\n    \}\n\n    else if (diagnosticMode == 101)\n    \{\n      // convert luminanceXYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n\n    else if (diagnosticMode == 102)\n    \{\n      // JMh to tonemappedJMh\n      diagnostic = forwardTonescale(srcRGB, extraRGB);\n    \}\n\n    else if (diagnosticMode == 103)\n    \{\n      // JMh to gamut compressed JMh\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    else if (diagnosticMode == 104)\n    \{\n      // JMh to luminance XYZ\n      diagnostic = JMh_to_XYZ( srcRGB, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n\n    else if (diagnosticMode == 105)\n    \{\n      // luminance XYZ to luminanceRGB\n      diagnostic = JMh_to_output_RGB(srcRGB);\n    \}\n\n    else if (diagnosticMode == 106)\n    \{\n      // luminanceRGB to output RGB\n      diagnostic = luminanceToEncoding3( encodingOut, srcRGB);\n    \}\n\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_simpleCompressMode {{parent.BlinkScript1_DRT_CAM_Kernel_simpleCompressMode}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_Locuscompressmode {{parent.BlinkScript1_DRT_CAM_Kernel_Locuscompressmode}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 104
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -201
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Group {
 name DRT_CAM6
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos -488
 ypos 1592
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {6 BlinkScript1_DRT_CAM_Kernel_simpleCompressMode l simpleCompressMode -STARTLINE}
 BlinkScript1_DRT_CAM_Kernel_simpleCompressMode true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit P3-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 1000
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.7 1.2 1.7 1}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_AP1compressmode l AP1compressmode T BlinkScript1.DRT_CAM_Kernel_AP1compressmode}
 addUserKnob {6 BlinkScript1_DRT_CAM_Kernel_Locuscompressmode l Locuscompressmode +STARTLINE}
 BlinkScript1_DRT_CAM_Kernel_Locuscompressmode true
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.2 1.4 {compressionFuncParamsR.g} 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {{compressionFuncParamsR.r} 1.21 {compressionFuncParamsY.g} 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {{compressionFuncParamsR.r} 1.3 {compressionFuncParamsG.g} 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {{compressionFuncParamsR.r} 1.9 {compressionFuncParamsC.g} 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {{compressionFuncParamsR.r} 1.2 {compressionFuncParamsB.g} 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {{compressionFuncParamsR.r} 1.23 {compressionFuncParamsM.g} 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out sRGB
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out sRGB/Rec.709-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name extra
  xpos -1244
  ypos -259
  number 1
 }
 Reformat {
  inputs 0
  name Reformat1
  xpos -1120
  ypos -264
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input1]"}}
  name Switch1
  xpos -1120
  ypos -195
 }
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  inputs 2
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v038.blink
  recompileCount 2561
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b01ab31261204a9edd5ee1cd13bdd2e603d7a9a00100add44c8b8f3d5ce677ab 3 \"src\" Read Point \"extra\" Read Point \"dst\" Write Point 74 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"simpleCompressMode\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"AP1compressmode\" Bool 1 AA== \"Locuscompressmode\" Bool 1 AA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 74 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"simpleCompressMode\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"AP1compressmode\" 1 1 \"Locuscompressmode\" 1 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 52 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTableUnsortedAP1\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTableAP1\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LocusLimitMTable\" Float 1 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> extra; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n    bool simpleCompressMode;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n    bool AP1compressmode;\n    bool Locuscompressmode;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    float3x3 AP1_to_XYZ;\n    float3x3 XYZ_to_AP1;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 gamutCuspTableUnsortedAP1\[360];\n    float3 gamutCuspTableAP1\[360];\n    float3 cgamutCuspTable\[360];\n    float LocusLimitMTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n\n    // switch to treat incoming data as luminanceXYZ when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      luminanceXYZ = JMh;\n    \}\n\n\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    // return luminanceRGB when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      return luminanceRGB;\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n  // convert linear RGB values with the AP1 primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 AP1_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(AP1_to_XYZ, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n    float2 cuspFromTableAP1(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTableAP1\[0].z )\n    \{\n      lo = gamutCuspTableAP1\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTableAP1\[0];\n    \}\n    else if( h >= gamutCuspTableAP1\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTableAP1\[gamutCuspTableSize-1];\n      hi = gamutCuspTableAP1\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTableAP1\[i].z )\n        \{\n          lo = gamutCuspTableAP1\[i-1];\n          hi = gamutCuspTableAP1\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n\n  float2 cuspFromTableLocus(float h)\n  \{\n\n    // float lo;\n    // float hi;\n\n    // if( h <= LocusLimitMTable\[0] )\n    // \{\n    //   lo = LocusLimitMTable\[gamutCuspTableSize-1];\n    //   lo = lo-360.0f;\n    //   hi = LocusLimitMTable\[0];\n    // \}\n    // else if( h >= LocusLimitMTable\[gamutCuspTableSize-1] )\n    // \{\n    //   lo = LocusLimitMTable\[gamutCuspTableSize-1];\n    //   hi = LocusLimitMTable\[0];\n    //   hi = hi+360.f;\n    // \}\n    // else\n    // \{\n    //   for(int i = 1; i < gamutCuspTableSize; ++i)\n    //   \{\n    //     if( h <= LocusLimitMTable\[i] )\n    //     \{\n    //       lo = LocusLimitMTable\[i-1];\n    //       hi = LocusLimitMTable\[i];\n    //       break;\n    //     \}\n    //   \}\n    // \}\n\n    // float t = (h - lo) / (hi - lo);\n\n    float cuspJ = 69;\n    // float cuspM = lerp(lo, hi, t);\n    float cuspM = LocusLimitMTable\[int(h)];\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (simpleCompressMode)\n    \{\n      if (!invert)\n      \{\n        M =  JMh.y * ( JMh.x / origJ);\n      \}\n      else\n      \{\n        M =  JMh.y * ( JMh.x / origJ);\n      \}\n      return M;\n    \}\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n      M = min(M,JMh.y);\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6 || diagnosticMode == 100)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n  float3 getLocusBoundry(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float2 cuspLocus = cuspFromTableLocus(h);\n    float cuspTarget100 = cuspLocus.y;\n    // 0.86 has been eyeballed to match the locus in Nuke\n    float cuspTarget = cuspTarget100 * pow((Jmh.x/100.0f),0.86f);\n    float difference =  cuspLocus.y / cuspTarget;\n    return float3(Jmh.x,cuspTarget,Jmh.z);\n  \}\n\n\n  float4 getCompressionFuncParams(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float angleR = 20.0f;\n    float angleY = 102.0f;\n    float angleG = 146.0f;\n    float angleC = 193.0f;\n    float angleB = 259.0f;\n    float angleM = 342.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if(AP1compressmode)\n    \{\n        float2 cuspAP1 = cuspFromTableAP1(h);\n        float2 cuspTarget = cuspFromTable(h);\n        float difference =  cuspAP1.y / cuspTarget.y;\n        return float4(0.2,difference,difference,1.0);\n    \}\n    if(Locuscompressmode)\n    \{\n        // float2 cuspLocus = cuspFromTableLocus(h);\n        float cuspTarget = cuspFromTable(h).y;\n        float locusMax = getLocusBoundry(Jmh).y;\n        // float cuspTarget = cuspTarget100 * (Jmh.x/100.0f);\n        float difference =  locusMax / Jmh.y;\n        // float difference = Jmh.y;\n        return float4(compressionFuncParams.x,difference,difference,compressionFuncParams.w);\n        // return float4(compressionFuncParams.x,locusMax,Jmh.y,compressionFuncParams.w);\n    \}\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    // float2 project_to = float2(project_from.x, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n    // float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_from, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMh.x,JMboundary.y,JMh.z));\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      // JMcompressed = project_to + v * (JMboundary - project_to);\n      JMcompressed = float2(JMh.x,v*JMboundary.y);\n    \}\n\n    // Diagnostic outputs\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 18)\n    \{\n      // return float3(interpolatedCompressionFuncParams.y, interpolatedCompressionFuncParams.z, JMh.z);\n      return float3(JMh.x, JMboundary.y, JMh.z);\n    \}\n    // actual output\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // M Max data generated via an external Nukescript at a J value of 100\n    float LocusLimitMTable_data\[]=\n    \{\n      244.8230133, 245.4952393, 246.4431458, 247.1381531, 247.2368927, 246.8459778, 245.7083588, 244.2591095, 242.5463409, 240.4208374, 238.0180511, 235.4039917, 233.010849, 230.4004669, 227.8723602, 225.2279968, 222.7197876, 214.8562622, 206.1778564, 198.0664215, 190.9799347, 184.005127, 177.7472992, 172.2332611, 166.6447754, 161.64534, 156.9872284, 152.6203003, 148.3236084, 144.2987976, 140.8540192, 137.4315033, 134.3281555, 131.2306366, 128.3477631, 125.8098145, 123.1305542, 120.5120163, 118.3302231, 116.127861, 114.0526428, 112.1633072, 110.2943344, 108.4250336, 106.711853, 105.188797, 103.6860809, 102.2319641, 100.8348923, 99.51873779, 98.26163483, 97.04810333, 95.90451813, 94.84623718, 93.86389923, 92.9352951, 92.03639984, 91.15013885, 90.27630615, 89.43255615, 88.63536072, 87.8986969, 87.23329163, 86.63896942, 86.09989166, 85.60071564, 85.12715912, 84.66781616, 84.21458435, 83.76491547, 83.30849457, 82.86478424, 82.46378326, 82.11483002, 81.82078552, 81.58016968, 81.37005615, 81.18525696, 81.01979065, 80.86772156, 80.72546387, 80.59381104, 80.48122406, 80.40287018, 80.33755493, 80.30010986, 80.28891754, 80.28807831, 80.33933258, 80.44513702, 80.57379913, 80.71469879, 80.86810303, 81.03874207, 81.23072052, 81.44044495, 81.6555481, 81.901474, 82.20778656, 82.67211151, 83.1408844, 83.62628174, 84.0898056, 84.53721619, 84.99518585, 85.49137878, 86.03423309, 86.58794403, 87.16802979, 87.72124481, 88.51965332, 89.35781097, 90.16739655, 90.94639587, 91.75927734, 92.65882111, 93.6033783, 94.64561462, 95.68405914, 96.84765625, 97.98625183, 99.09587097, 100.2806396, 101.5832748, 103.0694122, 104.6378632, 106.2420197, 107.8503952, 109.5214844, 111.3000031, 113.1901169, 115.1414337, 117.1432114, 119.3193054, 121.7141724, 124.2319031, 126.4584961, 128.9876556, 131.6906891, 134.7160034, 137.8343048, 140.7224121, 143.7820892, 147.23909, 150.6812439, 154.0381317, 157.1765747, 160.5133972, 164.2957306, 168.1366272, 171.8247986, 175.4206543, 179.2828827, 182.0374146, 185.0783844, 188.2106171, 190.9611206, 193.3639221, 195.5132294, 197.58255, 199.4234161, 201.3786011, 203.1474609, 205.016037, 206.6236725, 208.1813812, 209.8205719, 211.2774353, 212.8192749, 214.4571686, 215.6442261, 216.4818726, 217.1617279, 217.7372131, 218.2023926, 218.4073486, 218.4278564, 217.6643677, 216.4666748, 215.1212463, 213.8158264, 212.5012817, 210.8331757, 208.8956146, 206.9006958, 204.9239197, 203.0310059, 201.2084045, 199.3484344, 197.3464355, 195.217453, 193.0449677, 190.9578705, 188.9528656, 187.0009918, 185.0068817, 182.9402924, 180.8367767, 178.7057037, 176.5325165, 174.445282, 172.4908905, 170.5744934, 168.5490723, 166.459259, 164.4333649, 162.5092621, 160.4579468, 158.491806, 156.6880035, 155.0045624, 153.295166, 151.4545441, 149.5910492, 147.7821808, 146.4078522, 144.8022614, 143.2662506, 141.8236542, 140.5029602, 139.225174, 137.8959045, 136.4792175, 135.0780334, 133.7389374, 132.7613525, 131.6787109, 130.6356354, 129.64328, 128.7269897, 127.8450623, 126.9439697, 126.0015182, 125.0760727, 124.1718826, 123.4704056, 122.8062363, 122.1408768, 121.501358, 120.9004822, 120.3225555, 119.7514191, 119.2011871, 118.7055511, 118.2950592, 117.9416199, 117.5793762, 117.2029953, 116.8356552, 116.4874039, 116.1693954, 115.9030762, 115.6935577, 115.5213852, 115.3659363, 115.2032318, 115.0445251, 114.9317932, 114.8815384, 114.8605118, 114.8510284, 114.8482819, 114.848465, 114.8521805, 114.8999329, 115.0081787, 115.1483612, 115.2983322, 115.511528, 115.7195816, 115.9448853, 116.2098999, 116.5264893, 116.8126144, 117.1579666, 117.5379944, 117.9048004, 118.3263168, 118.8006821, 119.2988586, 119.8310318, 120.3776703, 121.0383987, 121.6810684, 122.4489899, 123.207077, 124.071022, 124.9082108, 125.74823, 126.6865311, 127.4425888, 127.8552094, 128.1067963, 128.3630676, 128.6606598, 128.9203491, 129.2632141, 129.708252, 130.1131287, 130.5647278, 130.9923553, 131.5979462, 132.2623444, 132.8651428, 133.4651947, 134.1470337, 134.8683624, 135.683609, 136.6136017, 137.5203552, 138.3826599, 139.2931976, 140.2762299, 141.2150574, 142.3930054, 143.7060547, 145.0472565, 146.3404083, 147.6144257, 148.9406586, 150.3545532, 151.8509674, 153.4246826, 155.0567017, 156.7265472, 158.4546509, 160.2428131, 162.1348267, 164.1415863, 166.2302551, 168.4024506, 170.5583649, 172.6457672, 174.9460449, 177.2792664, 179.6472473, 182.1867218, 184.5882721, 187.3068848, 189.8807373, 192.5116577, 195.5551453, 198.5196381, 201.3429413, 203.941452, 206.8439484, 209.5599213, 212.4866943, 215.0750885, 217.929306, 220.6668701, 223.364151, 226.2115479, 228.9524536, 231.5583954, 234.405304, 237.0275879, 239.5091705, 242.0047455, 242.0177155\n    \};\n\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    XYZ_to_AP1.setArray(XYZ_to_AP1_ACES_matrix_data);\n    AP1_to_XYZ = XYZ_to_AP1.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n\n    // LocusLimitMTable = LocusLimitMTable_data;\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      LocusLimitMTable\[i] = LocusLimitMTable_data\[i];\n    \}\n\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n  // Cusp table for limiting gamut\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n    \n    // Cusp table for AP1 gamut\n    \{\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsortedAP1\[i] = AP1_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsortedAP1\[i].z <  gamutCuspTableUnsortedAP1\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTableAP1\[i] = gamutCuspTableUnsortedAP1\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n  \}\n\n\n\n\n\}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    SampleType(extra) sourceExtra = src();\n    float3 extraRGB(sourceExtra.x, sourceExtra.y, sourceExtra.z);\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      if( invert )\n      \{\n        diagnostic =  JMh_to_input_RGB(srcRGB);\n      \}\n      else\n      \{\n        diagnostic =  JMh;\n      \}\n\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    else if (diagnosticMode == 14)\n    \{\n      // output gamut cusp\n      diagnostic = float3(cuspFromTable(srcRGB.z).x, cuspFromTable(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 15)\n    \{\n      // output AP1 cusp\n      diagnostic = float3(cuspFromTableAP1(srcRGB.z).x, cuspFromTableAP1(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 16)\n    \{\n      // output Locus cusp\n      diagnostic = float3(cuspFromTableLocus(srcRGB.z).x, cuspFromTableLocus(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 17)\n    \{\n      // output Locus boundry\n      diagnostic = getLocusBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 18)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0  );\n    \}\n\n\n\n\n    // extra modes to allow for easier breakout of the order of events.\n    // modes starting with 100\n\n    else if (diagnosticMode == 100)\n    \{\n      // output input as luminanceXYZ\n      diagnostic = input_RGB_to_JMh(srcRGB);\n    \}\n\n    else if (diagnosticMode == 101)\n    \{\n      // convert luminanceXYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n\n    else if (diagnosticMode == 102)\n    \{\n      // JMh to tonemappedJMh\n      diagnostic = forwardTonescale(srcRGB, extraRGB);\n    \}\n\n    else if (diagnosticMode == 103)\n    \{\n      // JMh to gamut compressed JMh\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    else if (diagnosticMode == 104)\n    \{\n      // JMh to luminance XYZ\n      diagnostic = JMh_to_XYZ( srcRGB, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n\n    else if (diagnosticMode == 105)\n    \{\n      // luminance XYZ to luminanceRGB\n      diagnostic = JMh_to_output_RGB(srcRGB);\n    \}\n\n    else if (diagnosticMode == 106)\n    \{\n      // luminanceRGB to output RGB\n      diagnostic = luminanceToEncoding3( encodingOut, srcRGB);\n    \}\n\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_simpleCompressMode {{parent.BlinkScript1_DRT_CAM_Kernel_simpleCompressMode}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_Locuscompressmode {{parent.BlinkScript1_DRT_CAM_Kernel_Locuscompressmode}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 105
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -201
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Group {
 name DRT_CAM7
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos -488
 ypos 1823
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {6 BlinkScript1_DRT_CAM_Kernel_simpleCompressMode l simpleCompressMode -STARTLINE}
 BlinkScript1_DRT_CAM_Kernel_simpleCompressMode true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit sRGB/Rec.709-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 1000
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.7 1.2 1.7 1}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_AP1compressmode l AP1compressmode T BlinkScript1.DRT_CAM_Kernel_AP1compressmode}
 addUserKnob {6 BlinkScript1_DRT_CAM_Kernel_Locuscompressmode l Locuscompressmode +STARTLINE}
 BlinkScript1_DRT_CAM_Kernel_Locuscompressmode true
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.2 1.4 {compressionFuncParamsR.g} 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {{compressionFuncParamsR.r} 1.21 {compressionFuncParamsY.g} 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {{compressionFuncParamsR.r} 1.3 {compressionFuncParamsG.g} 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {{compressionFuncParamsR.r} 1.9 {compressionFuncParamsC.g} 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {{compressionFuncParamsR.r} 1.2 {compressionFuncParamsB.g} 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {{compressionFuncParamsR.r} 1.23 {compressionFuncParamsM.g} 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out sRGB
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out sRGB/Rec.709-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name extra
  xpos -1244
  ypos -259
  number 1
 }
 Reformat {
  inputs 0
  name Reformat1
  xpos -1120
  ypos -264
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input1]"}}
  name Switch1
  xpos -1120
  ypos -195
 }
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  inputs 2
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v038.blink
  recompileCount 2561
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b01ab31261204a9edd5ee1cd13bdd2e603d7a9a00100add44c8b8f3d5ce677ab 3 \"src\" Read Point \"extra\" Read Point \"dst\" Write Point 74 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"simpleCompressMode\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"AP1compressmode\" Bool 1 AA== \"Locuscompressmode\" Bool 1 AA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 74 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"simpleCompressMode\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"AP1compressmode\" 1 1 \"Locuscompressmode\" 1 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 52 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTableUnsortedAP1\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTableAP1\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"LocusLimitMTable\" Float 1 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eRead, eAccessPoint, eEdgeClamped> extra; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n    bool simpleCompressMode;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n    bool AP1compressmode;\n    bool Locuscompressmode;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    float3x3 AP1_to_XYZ;\n    float3x3 XYZ_to_AP1;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 gamutCuspTableUnsortedAP1\[360];\n    float3 gamutCuspTableAP1\[360];\n    float3 cgamutCuspTable\[360];\n    float LocusLimitMTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n\n    // switch to treat incoming data as luminanceXYZ when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      luminanceXYZ = JMh;\n    \}\n\n\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    // return luminanceRGB when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      return luminanceRGB;\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n  // convert linear RGB values with the AP1 primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 AP1_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(AP1_to_XYZ, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *Helmholtz–Kohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n    float2 cuspFromTableAP1(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTableAP1\[0].z )\n    \{\n      lo = gamutCuspTableAP1\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTableAP1\[0];\n    \}\n    else if( h >= gamutCuspTableAP1\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTableAP1\[gamutCuspTableSize-1];\n      hi = gamutCuspTableAP1\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTableAP1\[i].z )\n        \{\n          lo = gamutCuspTableAP1\[i-1];\n          hi = gamutCuspTableAP1\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n\n  float2 cuspFromTableLocus(float h)\n  \{\n\n    // float lo;\n    // float hi;\n\n    // if( h <= LocusLimitMTable\[0] )\n    // \{\n    //   lo = LocusLimitMTable\[gamutCuspTableSize-1];\n    //   lo = lo-360.0f;\n    //   hi = LocusLimitMTable\[0];\n    // \}\n    // else if( h >= LocusLimitMTable\[gamutCuspTableSize-1] )\n    // \{\n    //   lo = LocusLimitMTable\[gamutCuspTableSize-1];\n    //   hi = LocusLimitMTable\[0];\n    //   hi = hi+360.f;\n    // \}\n    // else\n    // \{\n    //   for(int i = 1; i < gamutCuspTableSize; ++i)\n    //   \{\n    //     if( h <= LocusLimitMTable\[i] )\n    //     \{\n    //       lo = LocusLimitMTable\[i-1];\n    //       hi = LocusLimitMTable\[i];\n    //       break;\n    //     \}\n    //   \}\n    // \}\n\n    // float t = (h - lo) / (hi - lo);\n\n    float cuspJ = 69;\n    // float cuspM = lerp(lo, hi, t);\n    float cuspM = LocusLimitMTable\[int(h)];\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (simpleCompressMode)\n    \{\n      if (!invert)\n      \{\n        M =  JMh.y * ( JMh.x / origJ);\n      \}\n      else\n      \{\n        M =  JMh.y * ( JMh.x / origJ);\n      \}\n      return M;\n    \}\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n      M = min(M,JMh.y);\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6 || diagnosticMode == 100)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n  float3 getLocusBoundry(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float2 cuspLocus = cuspFromTableLocus(h);\n    float cuspTarget100 = cuspLocus.y;\n    // 0.86 has been eyeballed to match the locus in Nuke\n    float cuspTarget = cuspTarget100 * pow((Jmh.x/100.0f),0.86f);\n    float difference =  cuspLocus.y / cuspTarget;\n    return float3(Jmh.x,cuspTarget,Jmh.z);\n  \}\n\n\n  float4 getCompressionFuncParams(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float angleR = 20.0f;\n    float angleY = 102.0f;\n    float angleG = 146.0f;\n    float angleC = 193.0f;\n    float angleB = 259.0f;\n    float angleM = 342.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if(AP1compressmode)\n    \{\n        float2 cuspAP1 = cuspFromTableAP1(h);\n        float2 cuspTarget = cuspFromTable(h);\n        float difference =  cuspAP1.y / cuspTarget.y;\n        return float4(0.2,difference,difference,1.0);\n    \}\n    if(Locuscompressmode)\n    \{\n        // float2 cuspLocus = cuspFromTableLocus(h);\n        float cuspTarget = cuspFromTable(h).y;\n        float locusMax = getLocusBoundry(Jmh).y;\n        // float cuspTarget = cuspTarget100 * (Jmh.x/100.0f);\n        float difference =  locusMax / Jmh.y;\n        // float difference = Jmh.y;\n        return float4(compressionFuncParams.x,difference,difference,compressionFuncParams.w);\n        // return float4(compressionFuncParams.x,locusMax,Jmh.y,compressionFuncParams.w);\n    \}\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    // float2 project_to = float2(project_from.x, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n    // float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_from, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMh.x,JMboundary.y,JMh.z));\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      // JMcompressed = project_to + v * (JMboundary - project_to);\n      JMcompressed = float2(JMh.x,v*JMboundary.y);\n    \}\n\n    // Diagnostic outputs\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 18)\n    \{\n      // return float3(interpolatedCompressionFuncParams.y, interpolatedCompressionFuncParams.z, JMh.z);\n      return float3(JMh.x, JMboundary.y, JMh.z);\n    \}\n    // actual output\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // M Max data generated via an external Nukescript at a J value of 100\n    float LocusLimitMTable_data\[]=\n    \{\n      244.8230133, 245.4952393, 246.4431458, 247.1381531, 247.2368927, 246.8459778, 245.7083588, 244.2591095, 242.5463409, 240.4208374, 238.0180511, 235.4039917, 233.010849, 230.4004669, 227.8723602, 225.2279968, 222.7197876, 214.8562622, 206.1778564, 198.0664215, 190.9799347, 184.005127, 177.7472992, 172.2332611, 166.6447754, 161.64534, 156.9872284, 152.6203003, 148.3236084, 144.2987976, 140.8540192, 137.4315033, 134.3281555, 131.2306366, 128.3477631, 125.8098145, 123.1305542, 120.5120163, 118.3302231, 116.127861, 114.0526428, 112.1633072, 110.2943344, 108.4250336, 106.711853, 105.188797, 103.6860809, 102.2319641, 100.8348923, 99.51873779, 98.26163483, 97.04810333, 95.90451813, 94.84623718, 93.86389923, 92.9352951, 92.03639984, 91.15013885, 90.27630615, 89.43255615, 88.63536072, 87.8986969, 87.23329163, 86.63896942, 86.09989166, 85.60071564, 85.12715912, 84.66781616, 84.21458435, 83.76491547, 83.30849457, 82.86478424, 82.46378326, 82.11483002, 81.82078552, 81.58016968, 81.37005615, 81.18525696, 81.01979065, 80.86772156, 80.72546387, 80.59381104, 80.48122406, 80.40287018, 80.33755493, 80.30010986, 80.28891754, 80.28807831, 80.33933258, 80.44513702, 80.57379913, 80.71469879, 80.86810303, 81.03874207, 81.23072052, 81.44044495, 81.6555481, 81.901474, 82.20778656, 82.67211151, 83.1408844, 83.62628174, 84.0898056, 84.53721619, 84.99518585, 85.49137878, 86.03423309, 86.58794403, 87.16802979, 87.72124481, 88.51965332, 89.35781097, 90.16739655, 90.94639587, 91.75927734, 92.65882111, 93.6033783, 94.64561462, 95.68405914, 96.84765625, 97.98625183, 99.09587097, 100.2806396, 101.5832748, 103.0694122, 104.6378632, 106.2420197, 107.8503952, 109.5214844, 111.3000031, 113.1901169, 115.1414337, 117.1432114, 119.3193054, 121.7141724, 124.2319031, 126.4584961, 128.9876556, 131.6906891, 134.7160034, 137.8343048, 140.7224121, 143.7820892, 147.23909, 150.6812439, 154.0381317, 157.1765747, 160.5133972, 164.2957306, 168.1366272, 171.8247986, 175.4206543, 179.2828827, 182.0374146, 185.0783844, 188.2106171, 190.9611206, 193.3639221, 195.5132294, 197.58255, 199.4234161, 201.3786011, 203.1474609, 205.016037, 206.6236725, 208.1813812, 209.8205719, 211.2774353, 212.8192749, 214.4571686, 215.6442261, 216.4818726, 217.1617279, 217.7372131, 218.2023926, 218.4073486, 218.4278564, 217.6643677, 216.4666748, 215.1212463, 213.8158264, 212.5012817, 210.8331757, 208.8956146, 206.9006958, 204.9239197, 203.0310059, 201.2084045, 199.3484344, 197.3464355, 195.217453, 193.0449677, 190.9578705, 188.9528656, 187.0009918, 185.0068817, 182.9402924, 180.8367767, 178.7057037, 176.5325165, 174.445282, 172.4908905, 170.5744934, 168.5490723, 166.459259, 164.4333649, 162.5092621, 160.4579468, 158.491806, 156.6880035, 155.0045624, 153.295166, 151.4545441, 149.5910492, 147.7821808, 146.4078522, 144.8022614, 143.2662506, 141.8236542, 140.5029602, 139.225174, 137.8959045, 136.4792175, 135.0780334, 133.7389374, 132.7613525, 131.6787109, 130.6356354, 129.64328, 128.7269897, 127.8450623, 126.9439697, 126.0015182, 125.0760727, 124.1718826, 123.4704056, 122.8062363, 122.1408768, 121.501358, 120.9004822, 120.3225555, 119.7514191, 119.2011871, 118.7055511, 118.2950592, 117.9416199, 117.5793762, 117.2029953, 116.8356552, 116.4874039, 116.1693954, 115.9030762, 115.6935577, 115.5213852, 115.3659363, 115.2032318, 115.0445251, 114.9317932, 114.8815384, 114.8605118, 114.8510284, 114.8482819, 114.848465, 114.8521805, 114.8999329, 115.0081787, 115.1483612, 115.2983322, 115.511528, 115.7195816, 115.9448853, 116.2098999, 116.5264893, 116.8126144, 117.1579666, 117.5379944, 117.9048004, 118.3263168, 118.8006821, 119.2988586, 119.8310318, 120.3776703, 121.0383987, 121.6810684, 122.4489899, 123.207077, 124.071022, 124.9082108, 125.74823, 126.6865311, 127.4425888, 127.8552094, 128.1067963, 128.3630676, 128.6606598, 128.9203491, 129.2632141, 129.708252, 130.1131287, 130.5647278, 130.9923553, 131.5979462, 132.2623444, 132.8651428, 133.4651947, 134.1470337, 134.8683624, 135.683609, 136.6136017, 137.5203552, 138.3826599, 139.2931976, 140.2762299, 141.2150574, 142.3930054, 143.7060547, 145.0472565, 146.3404083, 147.6144257, 148.9406586, 150.3545532, 151.8509674, 153.4246826, 155.0567017, 156.7265472, 158.4546509, 160.2428131, 162.1348267, 164.1415863, 166.2302551, 168.4024506, 170.5583649, 172.6457672, 174.9460449, 177.2792664, 179.6472473, 182.1867218, 184.5882721, 187.3068848, 189.8807373, 192.5116577, 195.5551453, 198.5196381, 201.3429413, 203.941452, 206.8439484, 209.5599213, 212.4866943, 215.0750885, 217.929306, 220.6668701, 223.364151, 226.2115479, 228.9524536, 231.5583954, 234.405304, 237.0275879, 239.5091705, 242.0047455, 242.0177155\n    \};\n\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    XYZ_to_AP1.setArray(XYZ_to_AP1_ACES_matrix_data);\n    AP1_to_XYZ = XYZ_to_AP1.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n\n    // LocusLimitMTable = LocusLimitMTable_data;\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      LocusLimitMTable\[i] = LocusLimitMTable_data\[i];\n    \}\n\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n  // Cusp table for limiting gamut\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n    \n    // Cusp table for AP1 gamut\n    \{\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsortedAP1\[i] = AP1_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsortedAP1\[i].z <  gamutCuspTableUnsortedAP1\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTableAP1\[i] = gamutCuspTableUnsortedAP1\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n  \}\n\n\n\n\n\}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    SampleType(extra) sourceExtra = src();\n    float3 extraRGB(sourceExtra.x, sourceExtra.y, sourceExtra.z);\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      if( invert )\n      \{\n        diagnostic =  JMh_to_input_RGB(srcRGB);\n      \}\n      else\n      \{\n        diagnostic =  JMh;\n      \}\n\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    else if (diagnosticMode == 14)\n    \{\n      // output gamut cusp\n      diagnostic = float3(cuspFromTable(srcRGB.z).x, cuspFromTable(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 15)\n    \{\n      // output AP1 cusp\n      diagnostic = float3(cuspFromTableAP1(srcRGB.z).x, cuspFromTableAP1(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 16)\n    \{\n      // output Locus cusp\n      diagnostic = float3(cuspFromTableLocus(srcRGB.z).x, cuspFromTableLocus(srcRGB.z).y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 17)\n    \{\n      // output Locus boundry\n      diagnostic = getLocusBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 18)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0  );\n    \}\n\n\n\n\n    // extra modes to allow for easier breakout of the order of events.\n    // modes starting with 100\n\n    else if (diagnosticMode == 100)\n    \{\n      // output input as luminanceXYZ\n      diagnostic = input_RGB_to_JMh(srcRGB);\n    \}\n\n    else if (diagnosticMode == 101)\n    \{\n      // convert luminanceXYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n\n    else if (diagnosticMode == 102)\n    \{\n      // JMh to tonemappedJMh\n      diagnostic = forwardTonescale(srcRGB, extraRGB);\n    \}\n\n    else if (diagnosticMode == 103)\n    \{\n      // JMh to gamut compressed JMh\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    else if (diagnosticMode == 104)\n    \{\n      // JMh to luminance XYZ\n      diagnostic = JMh_to_XYZ( srcRGB, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n\n    else if (diagnosticMode == 105)\n    \{\n      // luminance XYZ to luminanceRGB\n      diagnostic = JMh_to_output_RGB(srcRGB);\n    \}\n\n    else if (diagnosticMode == 106)\n    \{\n      // luminanceRGB to output RGB\n      diagnostic = luminanceToEncoding3( encodingOut, srcRGB);\n    \}\n\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_simpleCompressMode {{parent.BlinkScript1_DRT_CAM_Kernel_simpleCompressMode}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_Locuscompressmode {{parent.BlinkScript1_DRT_CAM_Kernel_Locuscompressmode}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 106
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -201
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Viewer {
 inputs 2
 frame 58
 frame_range 1-78
 viewerProcess None
 monitorOutOutputTransform rec709
 name Viewer1
 xpos -488
 ypos 2011
}
